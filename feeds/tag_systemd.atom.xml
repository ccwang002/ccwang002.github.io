<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang-Bo Wang's Blog - systemd</title><link href="https://blog.liang2.tw/" rel="alternate"></link><link href="https://blog.liang2.tw/feeds/tag_systemd.atom.xml" rel="self"></link><id>https://blog.liang2.tw/</id><updated>2016-05-24T00:00:00-05:00</updated><entry><title>使用 conda env 部署 Django</title><link href="https://blog.liang2.tw/posts/2016/05/django-deploy-conda/" rel="alternate"></link><published>2016-05-24T00:00:00-05:00</published><updated>2016-05-24T00:00:00-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-05-24:/posts/2016/05/django-deploy-conda/</id><summary type="html">&lt;p&gt;沒幾天前剛部署一次 Django，記錄在&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;《使用 uWSGI、nginx、systemd 部署 Django》&lt;/a&gt;。今天又部署了另一個專案。部署的設定跟上次一樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一樣寫一個 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理網站的啟動 (uWSGI)。之後提到 &lt;code&gt;PROJ&lt;/code&gt; 時就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#conda"&gt;conda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi-path"&gt;uWSGI 和 $PATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sysmted-unit"&gt;在 sysmted unit 使用環境變數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;結論&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="conda"&gt;conda&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://conda.pydata.org/"&gt;conda&lt;/a&gt; 是一個 Python 套件的管理系統，他的好處是，遇到要使用外部 library 時，會這些套件相依的 library 都一併安裝管理 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;沒幾天前剛部署一次 Django，記錄在&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;《使用 uWSGI、nginx、systemd 部署 Django》&lt;/a&gt;。今天又部署了另一個專案。部署的設定跟上次一樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一樣寫一個 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理網站的啟動 (uWSGI)。之後提到 &lt;code&gt;PROJ&lt;/code&gt; 時就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#conda"&gt;conda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi-path"&gt;uWSGI 和 $PATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sysmted-unit"&gt;在 sysmted unit 使用環境變數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;結論&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="conda"&gt;conda&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://conda.pydata.org/"&gt;conda&lt;/a&gt; 是一個 Python 套件的管理系統，他的好處是，遇到要使用外部 library 時，會這些套件相依的 library 都一併安裝管理，也可以管理不同 Python 版本。可以想像是加強版的 pip + venv。conda 跟 pip 是相容的。&lt;/p&gt;
&lt;p&gt;這個 Django 專案就用到很多像 numpy、pandas 的套件。為了維護方便，我考慮用 conda 來安裝。我使用的是 &lt;a href="http://conda.pydata.org/miniconda.html"&gt;miniconda3&lt;/a&gt;，預設會安裝在 &lt;code&gt;~/miniconda3&lt;/code&gt; 底下，虛擬環境會出現在 &lt;code&gt;~/miniconda3/envs/&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ conda create -n VENV &lt;span class="nv"&gt;python&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.5 numpy pandas django
$ &lt;span class="nb"&gt;source&lt;/span&gt; activate VENV
&lt;span class="o"&gt;(&lt;/span&gt;VENV&lt;span class="o"&gt;)&lt;/span&gt; $ pip install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uWSGI 沒有在 conda 裡面，所以就用 pip 裝。從&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;上次的文章&lt;/a&gt;知道系統並不用安裝。&lt;/p&gt;
&lt;h3 id="uwsgi-path"&gt;uWSGI 和 $PATH&lt;/h3&gt;
&lt;p&gt;理論上，之後就照著上次操作就好，但在 uWSGI 就碰到問題：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;$ sudo /home/USER/miniconda3/envs/VENV/bin/uwsgi --ini PROJ.ini&lt;/span&gt;
&lt;span class="go"&gt;[uWSGI] getting INI configuration from PROJ.ini&lt;/span&gt;
&lt;span class="go"&gt;*** Starting uWSGI 2.0.13.1 (64bit) on [Wed May 25 08:04:23 2016] ***&lt;/span&gt;
&lt;span class="go"&gt;compiled with version: 5.3.1 20160413 on 25 May 2016 01:35:28&lt;/span&gt;
&lt;span class="go"&gt;os: Linux-4.4.0-22-generic #40-Ubuntu SMP Thu May 12 22:03:46 UTC 2016&lt;/span&gt;
&lt;span class="go"&gt;nodename: s66&lt;/span&gt;
&lt;span class="go"&gt;machine: x86_64&lt;/span&gt;
&lt;span class="go"&gt;clock source: unix&lt;/span&gt;
&lt;span class="go"&gt;detected number of CPU cores: 24&lt;/span&gt;
&lt;span class="go"&gt;current working directory: /etc/uwsgi/vassals&lt;/span&gt;
&lt;span class="go"&gt;detected binary path: /home/USER/miniconda3/envs/VENV/bin/uwsgi&lt;/span&gt;
&lt;span class="go"&gt;……&lt;/span&gt;
&lt;span class="go"&gt;chdir() to /path/to/PROJ/&lt;/span&gt;
&lt;span class="go"&gt;your processes number limit is 514650&lt;/span&gt;
&lt;span class="go"&gt;your memory page size is 4096 bytes&lt;/span&gt;
&lt;span class="go"&gt;detected max file descriptor number: 1024&lt;/span&gt;
&lt;span class="go"&gt;lock engine: pthread robust mutexes&lt;/span&gt;
&lt;span class="go"&gt;thunder lock: disabled (you can enable it with --thunder-lock)&lt;/span&gt;
&lt;span class="go"&gt;uwsgi socket 0 bound to UNIX address /run/PROJ/django.sock fd 3&lt;/span&gt;
&lt;span class="go"&gt;Python version: 3.5.1 |Continuum Analytics, Inc.| (default, Dec  7 2015, 11:16:01)  [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]&lt;/span&gt;
&lt;span class="go"&gt;Set PythonHome to /home/USER/miniconda3/envs/VENV&lt;/span&gt;
&lt;span class="go"&gt;Failed to import the site module&lt;/span&gt;
&lt;span class="gt"&gt;Traceback (most recent call last):&lt;/span&gt;
  File &lt;span class="nb"&gt;&amp;quot;/usr/lib/python3.5/site.py&amp;quot;&lt;/span&gt;, line &lt;span class="m"&gt;580&lt;/span&gt;, in &lt;span class="n"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gr"&gt;  …… &lt;/span&gt;
&lt;span class="gr"&gt;  File &amp;quot;/usr/lib/python3.5/_sysconfigdata.py&amp;quot;, line 6, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="gr"&gt;    from _sysconfigdata_m import *&lt;/span&gt;
&lt;span class="gr"&gt;ImportError&lt;/span&gt;: &lt;span class="n"&gt;No module named &amp;#39;_sysconfigdata_m&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但因為步驟實在太簡單，想不出來哪裡有錯，查網路也沒什麼相關的結果。在這邊卡了很久。&lt;/p&gt;
&lt;p&gt;結果後來才發現，Traceback 那邊 uWSGi 跑去讀到 &lt;code&gt;/usr/lib/python3.5/site.py&lt;/code&gt;，這表示一定有環境設錯才讓它找到這個不是我們要的 python 環境，理論上應該是找到 &lt;code&gt;/home/USER/miniconda3/envs/VENV/lib/python3.5/site.py&lt;/code&gt; 才對。&lt;/p&gt;
&lt;p&gt;經過一陣嘗試，發現只要修改 &lt;code&gt;$PATH&lt;/code&gt; 環境變數就能運作了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -i
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;span class="go"&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/home/USER/miniconda3/envs/VENV/bin:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; /home/USER/miniconda3/envs/VENV/bin/uwsgi --ini PROJ.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="sysmted-unit"&gt;在 sysmted unit 使用環境變數&lt;/h3&gt;
&lt;p&gt;根據 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#%24PATH"&gt;systemd.exec(5)&lt;/a&gt; 關於 &lt;code&gt;$PATH&lt;/code&gt; 環境變數的使用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Colon-separated list of directories to use when launching executables. Systemd uses a fixed value of /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;預設只有以上提到的路徑，如果要修改環境變數的話，就透過 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Environment="&gt;&lt;code&gt;Environment=&lt;/code&gt;&lt;/a&gt;，因此多加了一行在 systemd unit 裡。其餘的設定都是相同的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=PROJ Django server by uWSGI
After=syslog.target

[Service]
Environment=&amp;quot;PATH=/home/USER/miniconda3/envs/VENV/bin:$PATH&amp;quot;
ExecStart=/home/USER/miniconda3/envs/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini
Restart=always
KillSignal=SIGQUIT
Type=notify
StandardError=syslog
NotifyAccess=all

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_1"&gt;結論&lt;/h3&gt;
&lt;p&gt;如果要改用 conda 管理套件的話，只要在 systemd unit 那邊多加一行修改 $PATH，加入虛擬環境放執行檔的路徑，其餘的設定都與一般 Python 虛擬環境相同。這樣就搞定了。但這個問題花了我 1 個多小時……&lt;/p&gt;</content><category term="Coding"></category><category term="zh"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category><category term="conda"></category></entry><entry><title>使用 uWSGI、nginx、systemd 部署 Django</title><link href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/" rel="alternate"></link><published>2016-05-19T00:00:00-05:00</published><updated>2016-05-19T00:00:00-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-05-19:/posts/2016/05/django-deploy-uwsgi-nginx-systemd/</id><summary type="html">&lt;p&gt;上一次很認真的 Django 部署記錄在&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;《設定 Python 官方文件中文化自動更新 Server》&lt;/a&gt;一文。很巧地自己畢業的題目也要架個 Django 網站，所以就再跑了一次部署設定。舊文還提了有的沒的，這篇僅針對 Django 的部署。&lt;/p&gt;
&lt;p&gt;這邊的部署設定都儘量不使用 root 權限，整個連線的流程圖如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;寫一個名為 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理這網站的啟動與否。之後 &lt;code&gt;PROJ&lt;/code&gt; 就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;作業系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-proj"&gt;Django PROJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd"&gt;systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;確認、總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;使用 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上一次很認真的 Django 部署記錄在&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;《設定 Python 官方文件中文化自動更新 Server》&lt;/a&gt;一文。很巧地自己畢業的題目也要架個 Django 網站，所以就再跑了一次部署設定。舊文還提了有的沒的，這篇僅針對 Django 的部署。&lt;/p&gt;
&lt;p&gt;這邊的部署設定都儘量不使用 root 權限，整個連線的流程圖如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;寫一個名為 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理這網站的啟動與否。之後 &lt;code&gt;PROJ&lt;/code&gt; 就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;作業系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-proj"&gt;Django PROJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd"&gt;systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;確認、總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;使用 Ubuntu 16.04 LTS。我對 Ubuntu 其實沒愛，但因為很多人用，畢業之後應該還找得到人維護。他跟 Debian 差不多，所以跟舊文沒什麼差別。Ubuntu 16 內建就有 Python 3.5，不用再裝；PostgreSQL 也來到 9.5 版。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href="https://wiki.debian.org/UnattendedUpgrades"&gt;unattended-upgrades&lt;/a&gt; 定期更新與 security 相關的套件，它預設一天檢查一次，更新的記錄會在 &lt;code&gt;/var/log/unattended-upgrades&lt;/code&gt; 目錄中。&lt;/p&gt;
&lt;h3 id="postgresql"&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;參考&lt;a href="https://blog.liang2.tw/posts/2016/01/postgresql-install/"&gt;《安裝 PostgreSQL 9 於 Debian Jessie / OSX》&lt;/a&gt;一文設定。建立跟 OS user 同名的 PostgreSQL 帳號，給了建立 database 的權限，這樣開發比較方便。不用設定密碼。&lt;/p&gt;
&lt;h3 id="django-proj"&gt;Django PROJ&lt;/h3&gt;
&lt;p&gt;使用內建 &lt;a href="https://docs.python.org/3/library/venv.html"&gt;venv&lt;/a&gt; 在自己家目錄下某處，建立名為 &lt;code&gt;VENV&lt;/code&gt; 的虛擬環境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python3.5 -m venv VENV
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有關部署的設定（即 &lt;code&gt;settings.py&lt;/code&gt;），利用 &lt;a href="https://github.com/joke2k/django-environ"&gt;django-environ&lt;/a&gt; 把 secret key、database 連線資訊、寄信 SMTP server 等設定寫在獨立的檔案，就可以讓 local 和 production 環境讀到各自的設定。具體的做法可以參考 &lt;a href="https://github.com/pycontw/pycontw2016/blob/master/src/pycontw2016/settings/production.py"&gt;PyCon Taiwan 2016 網站管理設定&lt;/a&gt; 的寫法。&lt;/p&gt;
&lt;p&gt;在連 PostgreSQL 時使用 local connection (Unix-domain socket)，即使用者同名的身份。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="na"&gt;DATABASE_URL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;postgres:///TABLE_NAME&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="tmpfilesd"&gt;tmpfiles.d&lt;/h3&gt;
&lt;p&gt;把 nginx 與 uwsgi 溝通用的 socket 放在 &lt;code&gt;/run/PROJ&lt;/code&gt; 底下，但這也表示重開機之後，&lt;code&gt;/run/PROJ&lt;/code&gt; 資料夾就會消失不見，所以使用 &lt;a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles.d&lt;/a&gt;&lt;sup id="fnref:systemd-runtimedir"&gt;&lt;a class="footnote-ref" href="#fn:systemd-runtimedir"&gt;1&lt;/a&gt;&lt;/sup&gt;。除了資料夾的命名改成用專案名稱，設定都跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;一樣。&lt;/p&gt;
&lt;h3 id="nginx"&gt;nginx&lt;/h3&gt;
&lt;p&gt;nginx 設定跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;一樣。放在 &lt;code&gt;/etc/nginx/sites-available/PROJ.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Upstream Django setting; the socket nginx connects to&lt;/span&gt;
&lt;span class="k"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;django&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:///run/PROJ/django.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;default&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="s"&gt;.123.123.123&lt;/span&gt;
                &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;charset&lt;/span&gt;     &lt;span class="s"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="s"&gt;10M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# max upload size&lt;/span&gt;
    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/static&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/PROJ/assets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Finally, send all non-media requests to the Django server.&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt;  &lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;include&lt;/span&gt;     &lt;span class="s"&gt;/etc/nginx/uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;/path/to/PROJ/assets&lt;/code&gt; 是 Django &lt;a href="https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-STATIC_ROOT"&gt;STATIC_ROOT&lt;/a&gt; 的路徑。只要執行 &lt;code&gt;python manage.py collectstatic&lt;/code&gt; 後，即使 uWSGI 還沒設定就可以測試 /static/&amp;hellip;/ 有沒有被 nginx 抓到。 &lt;/p&gt;
&lt;p&gt;啟動時，先把檔案連結到 &lt;code&gt;/etc/nginx/site-enabled/&lt;/code&gt;，重載 nginx 設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/nginx/sites-enabled/
sudo ln -s ../sites-available/PROJ.conf .
sudo systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="uwsgi"&gt;uWSGI&lt;/h3&gt;
&lt;p&gt;跟舊文最大的差別，只要裝在 VENV 裡面就好了；然後也不使用 emperor mode。寫一個 &lt;code&gt;/etc/uwsgi/vassals/PROJ.ini&lt;/code&gt; 放設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;chdir&lt;/span&gt;        &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/PROJ&lt;/span&gt;
&lt;span class="c1"&gt;# Django&amp;#39;s wsgi file&lt;/span&gt;
&lt;span class="na"&gt;module&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;PROJ.wsgi:application&lt;/span&gt;
&lt;span class="na"&gt;env&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;DJANGO_SETTINGS_MODULE=PROJ.settings.production&lt;/span&gt;
&lt;span class="c1"&gt;# the virtualenv (full path)&lt;/span&gt;
&lt;span class="na"&gt;home&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/VENV&lt;/span&gt;

&lt;span class="c1"&gt;# process-related settings&lt;/span&gt;
&lt;span class="c1"&gt;# master&lt;/span&gt;
&lt;span class="na"&gt;master&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="c1"&gt;# maximum number of worker processes&lt;/span&gt;
&lt;span class="na"&gt;processes&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;4&lt;/span&gt;
&lt;span class="c1"&gt;# the socket (use the full path to be safe&lt;/span&gt;
&lt;span class="na"&gt;socket&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/run/PROJ/django.sock&lt;/span&gt;
&lt;span class="c1"&gt;# ... with appropriate permissions - may be needed&lt;/span&gt;
&lt;span class="na"&gt;chmod-socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;664&lt;/span&gt;
&lt;span class="na"&gt;uid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;USER&lt;/span&gt;
&lt;span class="na"&gt;gid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;www-data&lt;/span&gt;
&lt;span class="c1"&gt;# clear environment on exit&lt;/span&gt;
&lt;span class="na"&gt;vacuum&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;設定好後執行以下指令，就應該能看到網站能動了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /path/to/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="systemd"&gt;systemd&lt;/h3&gt;
&lt;p&gt;這邊除了執行 uWSGI 的指令不同外，都跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;相同。Debian 系 systemd system unit 設定檔放在 &lt;code&gt;/etc/systemd/system/PROJ.service&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=PROJ&amp;#39;s Django server by uWSGI
After=syslog.target

[Service]
ExecStart=/path/to/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini
Restart=always
KillSignal=SIGQUIT
Type=notify
StandardError=syslog
NotifyAccess=all

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這邊設定它會（有錯誤時）自動重新起動，並把 stderr 導到 syslog。接著，就要啟動這個 &lt;code&gt;PROJ.service&lt;/code&gt; 服務：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl &lt;span class="nb"&gt;enable&lt;/span&gt; PROJ
sudo systemctl status PROJ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以透過 &lt;code&gt;sudo journalctl -xe -u PROJ&lt;/code&gt; 來查看 uWSGI 執行、連線 log。&lt;/p&gt;
&lt;h3 id="_2"&gt;確認、總結&lt;/h3&gt;
&lt;p&gt;重啟系統一次，如果網站還活著，就表示一切設定都沒問題。整體上不太複雜，但權限不符的錯誤可能會讓你鬼打牆，要有耐心。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:systemd-runtimedir"&gt;
&lt;p&gt;也可以用 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html"&gt;systemd.exec(5)&lt;/a&gt; 提到的 &lt;code&gt;RuntimeDirectory=PROJ&lt;/code&gt; 來建立執行用目錄。但因為 &lt;code&gt;PROJ.service&lt;/code&gt; 的 USER 必須是 root，這種情況 man page 就建議改用 tmpfiles.d。我覺得應該能解決使用 root 權限的問題，但太懶了就先這樣……&amp;#160;&lt;a class="footnote-backref" href="#fnref:systemd-runtimedir" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category></entry><entry><title>設定 Python 官方文件中文化自動更新 Server</title><link href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/" rel="alternate"></link><published>2016-02-14T21:00:00-06:00</published><updated>2016-02-14T21:00:00-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-02-14:/posts/2016/02/pydoctw-server/</id><summary type="html">&lt;p&gt;設定一個自動更新 Python 說明文件中文翻譯並且 host 中文化網頁版文件的 server。使用 Django 作 web server、Django-Q 做為 task queue，deploy stack 用 nginx、uWSGI，host 於 Amazon EC2 (Debian Jessie)，資料庫用 PostgreSQL，並用 systemd 管理相關的 process。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt; 可至 &lt;a href="http://docs.python.org.tw"&gt;http://docs.python.org.tw&lt;/a&gt; 看線上自動更新的&lt;a href="http://docs.python.org.tw/3/"&gt;中文化的文件&lt;/a&gt;和 &lt;a href="http://docs.python.org.tw/_build/"&gt;build server&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;EDIT 2016-02-16: 加上 language code、git sshconfig、swap 的設定；文句潤飾。&lt;br&gt;
EDIT 2016-02-20: 加上 tmpfiles.d 的設定。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx"&gt;Sphinx 文件多國語言架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;翻譯體驗改善&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;實作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx_1"&gt;Sphinx 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-django-server"&gt;Autobuild Django server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-server"&gt;Autobuild server 部署&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;作業系統&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;資料庫 PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#swap"&gt;Swap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-repo-ssh-config"&gt;Git repo ssh config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI 設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd-services"&gt;Systemd services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="python"&gt;Python 說明文件中文翻譯計畫&lt;/h2&gt;
&lt;p&gt;最近一段時間都在準備 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;。翻譯本身雖然還沒很積極地進行，但經過&lt;a href="http://www.meetup.com/Taipei-py/events/226558484/"&gt;前&lt;/a&gt;&lt;a href="http://www.meetup.com/Taipei-py/events/227001232/"&gt;幾次&lt;/a&gt; Taipei.py Projects On 的 sprint 活動，已經有蠻多人加入翻譯的行列。大家都有各自翻譯的主題，像我自己是從 &lt;a href="http://docs.python.org.tw/3/tutorial/index.html"&gt;Tutorial&lt;/a&gt; 的部份開始翻譯。&lt;/p&gt;
&lt;h3 id="sphinx"&gt;Sphinx 文件多國語言架構&lt;/h3&gt;
&lt;p&gt;先簡介一下 &lt;a href="https://docs.python.org/3/"&gt;CPython Documentation&lt;/a&gt;（下稱 pydoc）的架構和翻譯方式。pydoc 是標準的 &lt;a href="http://www.sphinx-doc.org/en/stable/"&gt;Sphinx&lt;/a&gt; 文件，因此翻譯使用 Sphinx 自帶的 &lt;a href="http://www.sphinx-doc.org/en/stable/intl.html"&gt;internationalization&lt;/a&gt; (i18n or intl) 功能把文件的內容轉換到別的語言上。&lt;/p&gt;
&lt;p&gt;如同 Django 等專案，i18n 都是透過 gettext，Sphinx 會按照 rst 檔案輸出同檔名的 po 檔。rst 檔案中的每個文字段落會對應到 po 檔一個 entry，不相干的程式碼範例等段落會被跳過。輸出的 po 檔放在對應的路徑例如 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/LC_MESSAGES/xxx.po&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Gettext"&gt;po 檔的格式&lt;/a&gt;很簡單，跳過有的沒的 header，實質內容長這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;#: ../../tutorial/appetite.rst:50&lt;/span&gt;
&lt;span class="nv"&gt;msgid&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python enables programs to be written compactly and readably.  Programs &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;written in Python are typically much shorter than equivalent C,  C++, or &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Java programs, for several reasons:&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;msgstr&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python 讓程式寫得精簡並易讀。用 Python 實作的程式長度往往遠比用 &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;C、C++、Java 實作的短。這有以下幾個原因：&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;實際上 Sphinx 會先輸出一份乾淨的 po 檔範本（稱為 pot 檔）到 &lt;code&gt;locale/pot/&lt;/code&gt;，基本上就是只有原文的 po 檔。每增加一個新語言就會從 pot 檔製作一份 po 檔到各自的 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/&lt;/code&gt; 目錄下，翻譯時就修改那份 po 檔就可以。&lt;/p&gt;
&lt;p&gt;翻譯完成後，首先 Sphinx 會先呼叫 gettext 把 po 檔編譯成 mo 檔加速搜尋翻譯字串速度。輸出翻譯後的文件只要設定不同語言，Sphinx 就會去找該語言的 mo 檔，並把原文字串換成 mo 檔裡的內容，就可以看到中文的文件。&lt;/p&gt;
&lt;h3 id="transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/h3&gt;
&lt;p&gt;整個 Sphinx 文件翻譯流程就這樣，所以翻譯只要編輯中文 (lang code: zh-Hant&lt;sup id="fnref:zh-Hant"&gt;&lt;a class="footnote-ref" href="#fn:zh-Hant"&gt;1&lt;/a&gt;&lt;/sup&gt;) 的 po 檔就好了。不過要直接寫 po 檔格式門檻還是太高，於是就有像 &lt;a href="https://www.transifex.com/"&gt;Transifex&lt;/a&gt; 這樣的網站。上傳 po/pot 檔就能線上修改翻譯，然後再把翻完的結果用 po 檔格式下載下來。我認為這是現在參加以 gettext-based PO 檔翻譯門檻最低的方式，至少日本也是這麼做。於是想要參考 pydoc 翻譯的人，只要登入 Transifex 就可以開始編輯。&lt;/p&gt;
&lt;p&gt;用 Transifex 還有額外的好處。例如他有 POS tagging 可以標注專有名詞，定義統一的譯名，這些譯名會整理在 glossary terms 裡，翻譯時出現這些詞就會自動提示。類似的原文文句也會放在 suggestion 裡，讓翻譯完的用語文法也能一致。此外也有修改歷史、防呆提示（如該有的格式沒在譯文出現）、加註解 (comment)、評論 (issue) 等功能。&lt;/p&gt;
&lt;h3 id="_1"&gt;翻譯體驗改善&lt;/h3&gt;
&lt;p&gt;這段時間翻譯的用詞、流程等規範都有個雛型了，相關的內容都可以在&lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki"&gt;專案的 wiki&lt;/a&gt; 裡找到。所以開始想要怎麼讓大家更好參與翻譯和看到翻譯的結果。&lt;/p&gt;
&lt;p&gt;我發現參加翻譯本身已經不困難，大家沒什麼疑問。維護整體的用詞、翻譯討論用 Transifex issue 和 comment 效果不錯。整體上能保持極度分散式的工作形式。&lt;/p&gt;
&lt;p&gt;平常遇到最多問題是出現 rst 格式錯誤、缺少必要的空白、前後文加上程式碼範例之後不通順、譯文曲解或誤會原文的意思。這些問題，我覺得只要自己讀過翻完的 pydoc 該頁、看一下輸出的 log 就能明白，也不需要我多作解釋。&lt;/p&gt;
&lt;p&gt;再來，看不到自己翻譯的成果&lt;strong&gt;很沒有成就感&lt;/strong&gt;，過一段時間我怕會失去動力。&lt;/p&gt;
&lt;p&gt;於是變成需要一份保持更新的翻譯成果。當然自己輸出 doc 的方法都有寫在 &lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki/How-to-build-the-doc-locally"&gt;wiki&lt;/a&gt; 裡，但步驟很多，說簡單也沒多簡單，而且有錯或有問題可能都要來找我，就失去分散式分工的特性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不如做個 autobuild server。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;於是有了這想法。但實在是個大坑，一直只能用想的。在過年的時候總算找到時間把 prototype 做出來了，其實蠻有成就感的。&lt;/p&gt;
&lt;h2 id="pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/h2&gt;
&lt;p&gt;簡單整理幾個需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyDoc 結果網址對應本家 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt;。例如 /3/ 就是 Python 3.x 版最新的，而現在 /3.5/ 就會自動轉址到 /3/&lt;sup id="fnref:pydoc-url"&gt;&lt;a class="footnote-ref" href="#fn:pydoc-url"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;每一頁都有個更新翻譯連結，點一下就會從 Transifex 上抓新的翻譯，並更新輸出。&lt;/li&gt;
&lt;li&gt;更新每頁翻譯的指令輸出都要保留，方便檢查 rst 語法等錯誤。&lt;/li&gt;
&lt;li&gt;更新翻譯要有個 queue，才可以多人合作時不炸掉 autobuild server。&lt;/li&gt;
&lt;li&gt;每日更新全部的文件，並且把更新加到 CPython-tw 的 git repo 中。更新的過程一樣要有記錄。&lt;/li&gt;
&lt;li&gt;上述的所有功能都能在本機輕鬆地設定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;實作&lt;/h3&gt;
&lt;p&gt;目標就是完成上述的需求。pydoc 基本上就是個 static site，交給 nginx 設好路徑 host static files 就可以。Pydoc Sphinx 用 &lt;a href="http://jinja.pocoo.org/docs/dev/"&gt;Jinja2&lt;/a&gt; 作 HTML template，所以只要多加一些變數就能控制頁面的輸出，在 autobuild server 上時就可以加上額外的連結。而 Autobuild server 本身是個 task queue，其實功能很簡單，但為了維護方便，並考慮到 local、production 環境都要能動的話，選擇 &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; 為基礎。真的給 Django 管理的就顯示 task queue、task result、接受 rebuild doc request 這幾個 view。&lt;/p&gt;
&lt;h4 id="sphinx_1"&gt;Sphinx 文件&lt;/h4&gt;
&lt;p&gt;在 Sphinx 文件部份不想搞太複雜，就在每一頁加上一個自己的專屬連結，打這個網址就會加入一個更新該頁面的 task 到 autobuild server&lt;sup id="fnref:build-link"&gt;&lt;a class="footnote-ref" href="#fn:build-link"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;在 autobuild 時加入專屬連結只要修改 Sphinx doc template 即可。Sphinx 在 build doc 時可以透過 &lt;a href="http://www.sphinx-doc.org/en/stable/man/sphinx-build.html#options"&gt;&lt;code&gt;-A &amp;lt;name=value&amp;gt;&lt;/code&gt;&lt;/a&gt; 增加 Jinja2 template 的變數，就可控制 template render 行為：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;{# &amp;lt;cpython-src&amp;gt;/Doc/tools/templates/layout.html #}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;autobuildi18n&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/_build/update/?source_path=&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;pagename&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Update Translation&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sphinx-build -A autobuildi18n=1&lt;/code&gt; 時就會包含這個 Jinja2 block，多這個 Update Translation 連結。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sphinx-doc.org/en/stable/templating.html#pagename"&gt;&lt;code&gt;{{ pagename }}&lt;/code&gt;&lt;/a&gt; 是每頁文件的 rst 路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="autobuild-django-server"&gt;Autobuild Django server&lt;/h4&gt;
&lt;p&gt;Django server 目標就是接受 task request 和顯示 task result。一個標準的 task queue 就有這些功能。&lt;/p&gt;
&lt;p&gt;Django 上的 task queue 選擇很多，從 &lt;a href="https://www.djangopackages.com/"&gt;Django Packages&lt;/a&gt; 上的 &lt;a href="https://www.djangopackages.com/grids/g/workers-queues-tasks/"&gt;Workers, Queues, and Tasks&lt;/a&gt; 相關的套件可以看到有幾個有在更新而且 up 數多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://celery.github.io/django-celery/"&gt;django-celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://huey.readthedocs.org/en/latest/"&gt;huey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ui/django-rq"&gt;django-RQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://policystat.github.io/jobtastic/"&gt;jobtastic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扣掉不支援 Python 3 的套件&lt;sup id="fnref:python3"&gt;&lt;a class="footnote-ref" href="#fn:python3"&gt;4&lt;/a&gt;&lt;/sup&gt;後，就剩 django-celery、django-RQ、django-Q 可以選。這裡面最紅也最老牌的是 django-celery ，它與 &lt;a href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; 整合，功能完整且穩定，我用過也覺得十分不錯，缺點是功能太多有點複雜，加上不同 message queue 時會有很多設定要調整，需要一段時間上手。一般 Celery 常見的搭配使用 &lt;a href="https://www.rabbitmq.com/"&gt;Rabbit-MQ&lt;/a&gt; 和 &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;，的確在 task 很多時有必要，但我們這個 build doc 一天可能才十幾次，在不隔離 build doc 環境的情況同時間的 worker 只能有一個，不會有效能上的問題。因此我傾向只要使用與 Django 同一個 database 就好，不要再有額外非 Python 的 dependency，讓 local 開發簡單一點。&lt;/p&gt;
&lt;p&gt;最後選擇 &lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;。雖然很新但作者維護得很勤，worker 可以只用 Python 內建的 multiprocessing 完成。功能簡單卻完整，包含 monitor，跟 django-admin 整合，還可以排程。所以要啟動 django-Q 的 cluster，只要多一個 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python manage.py qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可，十分方便。&lt;/p&gt;
&lt;p&gt;怎麼使用 django-Q 就不在這篇 blog 討論範圍內了。我想我應該會投稿 PyCon TW 或 Taipei.py，到時候再整理成另一篇。Django-Q 的說明文件寫得很清楚，讀一讀應該就會了。&lt;/p&gt;
&lt;h2 id="autobuild-server"&gt;Autobuild server 部署&lt;/h2&gt;
&lt;p&gt;（這篇文的重點其實是部署，誰曉得背景介紹可以這麼長）&lt;/p&gt;
&lt;p&gt;部署 (deploy) 方法百百種，有好有壞。但至少要會一種嘛，所以這邊就用其中一種：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也算很流行的組合。更完整地來說，整個處理 request 的流程經過：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;web client &amp;lt;-&amp;gt; nginx web server &amp;lt;-&amp;gt; socket &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本的設定與教學來自 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/index.html"&gt;uWSGI&lt;/a&gt; 官網的 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文，搭配 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;uWGSI and Systemd&lt;/em&gt;&lt;/a&gt; 與 &lt;a href="https://www.freedesktop.org/wiki/Software/systemd/"&gt;systemd&lt;/a&gt; 整合。&lt;/p&gt;
&lt;p&gt;這也是目前 Pydoc production 的設定，記錄一下方便未來的維護。&lt;/p&gt;
&lt;h3 id="_3"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;作業系統用 Debian Jessie，架設於 Amazon EC2 上，使用 t2.nano&lt;sup id="fnref:ec2-nano"&gt;&lt;a class="footnote-ref" href="#fn:ec2-nano"&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;Python web deploy 都會把套件裝在虛擬環境中，避免不同專案間互衝或與系統衝突。在 Debian 上可以用 &lt;code&gt;apt buid-dep python3-&amp;lt;pkg&amp;gt;&lt;/code&gt; 把 Python &lt;pkg&gt; 套件所需的 header 或 library 安裝好，十分簡單。&lt;/p&gt;
&lt;h4 id="python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/h4&gt;
&lt;p&gt;我的 code 裡用到了 &lt;a href="https://docs.python.org/3/library/subprocess.html#subprocess.run"&gt;&lt;code&gt;subprocess.run&lt;/code&gt;&lt;/a&gt;，這是 Python 3.5+ 才有的 API。但 Jessie 只有 Python 3.4，但我覺得很好用一點都不想改寫成相容舊版的 code。&lt;/p&gt;
&lt;p&gt;因此需要安裝 Debian testing channel 上最新的 Python 3.5。這樣其實有安全上的疑慮，因為只有 stable channel 才有 security support，但自己編譯的問題更大，所以像 &lt;a href="https://github.com/yyuu/pyenv"&gt;pyenv&lt;/a&gt; 這種多 Python 版本的工具不在考慮內。&lt;/p&gt;
&lt;p&gt;於是用 &lt;a href="https://wiki.debian.org/AptPreferences"&gt;Apt-Pinning&lt;/a&gt; 只讓 Python 3.5 相關的套件安裝 testing 的版本。首先把 testing channel 加到 &lt;code&gt;/etc/apt/source.list&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;deb http://cloudfront.debian.net/debian testing main
deb-src http://cloudfront.debian.net/debian testing main
deb http://security.debian.org/ testing/updates main
deb-src http://security.debian.org/ testing/updates main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然後修改 &lt;code&gt;/etc/apt/preferences&lt;/code&gt; 確定我們不會不小心裝到 testing 相關的套件，並把 Python 3.5 相關的套件設定權限 &amp;gt;= 990 讓它們能被自動安裝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Specify * rules first so later package-specfic rules can override them
Package: *
Pin: release a=testing
Pin-Priority: -10

Package: python3.5* libpython3.5*
Pin: release a=testing
Pin-Priority: 990
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以用 &lt;code&gt;sudo apt-cache policy &amp;lt;pkg-name&amp;gt;&lt;/code&gt; 檢查目前的規則會裝到哪個版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt-get update 
$ sudo apt-get install python3.5 python3.5-venv python3.5-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣只有 Python 3.5 相關的套件才會裝到 testing。&lt;/p&gt;
&lt;h4 id="postgresql"&gt;資料庫 PostgreSQL&lt;/h4&gt;
&lt;p&gt;資料庫用 PostgreSQL 9.4。參照之前 blog&lt;a href="https://blog.liang2.tw/posts/2016/01/postgresql-install/"&gt;《安裝 PostgreSQL 9 於 Debian Jessie / OSX》&lt;/a&gt;一文設定。&lt;/p&gt;
&lt;h4 id="swap"&gt;Swap&lt;/h4&gt;
&lt;p&gt;其實是上線不久才注意到 EC2 預設沒有 swap 空間。我很窮所以 production server 的 RAM 只有 512 MB，觀察一下有時候 build doc RAM 就全滿了，所以還是加個 swap 安心一點。&lt;/p&gt;
&lt;p&gt;因為 Amazon EBS SSD I/O 數不會另外收錢（應該吧？），就建 swap file 在主硬碟裡。&lt;/p&gt;
&lt;p&gt;Swap 設定的教學很多，這邊就參考 &lt;a href="https://wiki.archlinux.org/index.php/swap"&gt;Arch Wiki&lt;/a&gt; 上的做法，我選擇放在 &lt;code&gt;/var/swap.1&lt;/code&gt;。大小設定為 RAM 的 2 倍，即 1GB。&lt;/p&gt;
&lt;p&gt;首先把這個檔案建出來，權限改為 600。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /bin/dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/swap.1 &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;
&lt;span class="c1"&gt;# or faster with fallocate&lt;/span&gt;
sudo fallocate -l 1G /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod &lt;span class="m"&gt;600&lt;/span&gt; /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再來把這個檔案改成 swap 格式並啟用它，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /sbin/mkswap /var/swap.1
sudo /sbin/swapon /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改 fstab 讓每次開機都有這個 swap 設定，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# /etc/fstab
/var/swap.1 none swap defaults 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用 &lt;code&gt;free -h&lt;/code&gt;、&lt;code&gt;cat /proc/meminfo&lt;/code&gt; 檢查此時應該有個 1GB swap 了。&lt;/p&gt;
&lt;h4 id="git-repo-ssh-config"&gt;Git repo ssh config&lt;/h4&gt;
&lt;p&gt;再來是 code 的同步與更新。autobuild server 只要更新 source code，但 cpython-tw source 需要定時 commit 新的翻譯，因此 deploy server 會有修改 git repo 的權限。&lt;/p&gt;
&lt;p&gt;不應該使用自己的 SSH key，deploy server 上應該有專屬的 deploy key，其中 cpython-tw 的 deploy key 有寫入權限（即可以 commit）。&lt;/p&gt;
&lt;p&gt;查了一下，要讓不同 git repo 使用不同的 SSH key 也不複雜。以這邊的例子，先修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 加入兩個新的 host，使用不同的 SSH key：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Host github-pydoc_autobuild
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.pydoc_autobuild

Host github-cpython_tw
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.cpython_tw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;建立對應的 SSH keypair，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa.pydoc_autobuild
ssh-keygen -t rsa -f ~/.ssh/id_rsa.cpython_tw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把兩個 repo 的 URL host 換掉，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git remote set-url origin git@github-pydoc_autobuild:python-doc-tw/pydoc_autobuild.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣兩個 repo 會透過給定的 ssh key 連線。GitHub 會顯示每個 key 最近使用的時間，檢查時間就能確認設定正確與否（而且改 host 沒設定對應該直接連不上）。&lt;/p&gt;
&lt;h4 id="tmpfilesd"&gt;tmpfiles.d&lt;/h4&gt;
&lt;p&gt;之後 nginx 和 uwsgi 溝通用的 socket 打算放在 &lt;code&gt;/run/django/xxxx.sock&lt;/code&gt; &lt;sup id="fnref:/run"&gt;&lt;a class="footnote-ref" href="#fn:/run"&gt;6&lt;/a&gt;&lt;/sup&gt;。因為只需要非 root 的權限，修改 &lt;a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles.d&lt;/a&gt; 的設定，讓這個資料夾能在開機時自動建立。增加設定檔 &lt;code&gt;/etc/tmpfiles.d/pydoc_autobuild.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;d /run/django 0755 pydoc www-data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/h3&gt;
&lt;p&gt;在本地開發都用 &lt;code&gt;python manage.py runserver&lt;/code&gt; 啟動 Django。但上線時內建的 runserver 就無法同時間服務太多人。因此需要像 nginx、uWSGI 等工具來協助。&lt;/p&gt;
&lt;p&gt;參照 uWSGI &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文以及 TP 寫的 《為程式人寫的 Django Tutorial》系列文中 &lt;a href="https://github.com/uranusjr/django-tutorial-for-programmers/blob/master/25-deploy-to-ubuntu-server.md"&gt;&lt;em&gt;Day 27 - Deploy to Ubuntu server&lt;/em&gt;&lt;/a&gt; 關於部署的文章。&lt;/p&gt;
&lt;p&gt;Autobuild server 有特別為 production 寫一份設定檔，切換時只要設定成 &lt;code&gt;settings.production&lt;/code&gt; 即可。在 Django 設定部份，建議把所有路徑都設成絕對路徑（包含執行檔）。不然後續在設定 systemd 要調整很多環境變數，systemd 也不會帶入使用者的 PATH 變數，不用絕對路徑其實蠻麻煩的也容易錯。&lt;/p&gt;
&lt;h4 id="nginx"&gt;nginx 設定&lt;/h4&gt;
&lt;p&gt;nginx 會接受 incoming HTTP request，需要跟 Django server 聯絡時，就會會連到 uWSGI 開的 UNIX socket。&lt;/p&gt;
&lt;p&gt;我們先假設 uWSGI 這段沒問題，首先設定 nginx 本身。由於 static files 在 nginx 就直接導到對應的檔案，不會經過 uWSGI ，所以設定好 nginx 之後 pydoc 文件本身就上線了。用這個來測試設定的正確性。&lt;/p&gt;
&lt;p&gt;對本網站而言，/static 導到 Django staticfiles；/3/、/3.5/ 導到 pydoc build HTML 的路徑；其餘路徑再交給 Django 處理。其中，/3.5/* 的連結將重新導向到 /3/* 上。&lt;/p&gt;
&lt;p&gt;整理上述的需求，寫個 nginx 設定檔在 &lt;code&gt;/etc/nginx/sites-available/pydoc_autobuild.conf&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Upstream Django setting; the socket nginx connects to&lt;/span&gt;
&lt;span class="k"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;django&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:///run/django/pydoc_autobuild.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;default&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;docs.python.org.tw&lt;/span&gt;
                &lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="s"&gt;.69.170.26&lt;/span&gt;
                &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;charset&lt;/span&gt;     &lt;span class="s"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="s"&gt;10M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# max upload size&lt;/span&gt;
    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/static&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/code/pydoc_autobuild/assets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/3&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/code/cpython-tw/Doc/build/html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;/3\.5/(.*)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;302&lt;/span&gt; &lt;span class="s"&gt;/3/&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Finally, send all non-media requests to the Django server.&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt;  &lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;include&lt;/span&gt;     &lt;span class="s"&gt;/etc/nginx/uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再把檔案 soft link 到 &lt;code&gt;/etc/nginx/sites-enabled/&lt;/code&gt;，更新 nginx 設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/nginx/sites-available/
sudo ln -s pydoc_autobuild.conf ../sites-enabled/
sudo systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;確定 pydoc 上線就可以專心處理 uWSGI 了。&lt;/p&gt;
&lt;h4 id="uwsgi"&gt;uWSGI 設定&lt;/h4&gt;
&lt;p&gt;uWSGI 在 VENV 外也要裝，我覺得還是用 pip 比較簡單，雖然這樣就要自己注意 uWSGI 的版本更新了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo python3.5 -m pip install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把 uWSGI 設定存成 &lt;code&gt;pydoc_autobuild_uwsgi.ini&lt;/code&gt; 並且在測試時，都使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo uwsgi --ini pydoc_autobuild_uwsgi.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模擬實際上的執行方式，這樣之後改用 systemd 執行才不會又丟一堆權限的問題。設定檔的內容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[uwsgi]
chdir        = /path/to/code/pydoc_autobuild
# Django&amp;#39;s wsgi file
module       = pydoc_autobuild.wsgi:application
env          = DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production
# the virtualenv (full path)
home         = /path/to/VENV

# process-related settings
# master
master       = true
# maximum number of worker processes
processes    = 4
# the socket (use the full path to be safe
socket       = /run/django/pydoc_autobuild.sock
# ... with appropriate permissions - may be needed
chmod-socket = 664
uid          = pydoc
gid          = www-data
# clear environment on exit
vacuum       = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;權限上的設定可能要花點時間處理一下，nginx 使用 www-data/www-data 的身份執行，socket 要確定 nginx 能讀寫，但我的 code 放在 pydoc 使用者路徑下，用 www-data 可能會有權限的問題。建議把 uid、gid 都設定好。&lt;/p&gt;
&lt;p&gt;過程中，搭配 nginx 的錯誤訊息比較好 debug：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo less +F /var/log/nginx/error.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;成功後，再用 uWSGI 的 Emperor mode，把設定檔丟到一個路徑底下（該路徑稱為 vassals）。uWSGI 在 Emperor mode 時會自動把 vassals 路徑內所有設定檔都讀進來並執行。&lt;/p&gt;
&lt;p&gt;這裡 vassals 路徑使用 &lt;code&gt;/etc/uwsgi/vassals/&lt;/code&gt;。因為有設 uid、gid，跑的時候就不用再設了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo uwsgi --emperor /etc/uwsgi/vassals
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣應該 Django 相關的 view 都沒問題了。接下來，要把啟動 uWSGI 的步驟交給系統來管理。&lt;/p&gt;
&lt;h3 id="systemd-services"&gt;Systemd services&lt;/h3&gt;
&lt;p&gt;Autobuild server 包含兩個部份：Django Server 與 Django-Q cluster。所以寫成 systemd service 時會有兩個服務。&lt;/p&gt;
&lt;p&gt;Debian system service 放在 &lt;code&gt;/etc/systemd/system/&lt;/code&gt; 底下，因此建立 &lt;code&gt;uwsgi.service&lt;/code&gt; 和 &lt;code&gt;qcluster.service&lt;/code&gt; 分別管理 uWSGI Emperor mode 和 Django-Q cluster。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uwsgi.service&lt;/code&gt; 參考 uWSGI 官網 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;Django and Systemd&lt;/em&gt;&lt;/a&gt; 一文的設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=uWSGI Emperor
After=syslog.target

[Service]
ExecStart=/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals
RuntimeDirectory=uwsgi
Restart=always
KillSignal=SIGQUIT
Type=notify
StandardError=syslog
NotifyAccess=all

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;qcluster.service&lt;/code&gt; 算是自己硬寫模擬 &lt;code&gt;python manage.py qcluster&lt;/code&gt; 行為。因此環境變數都要設定好（當然用絕對路徑就沒問題了，我只是覺得這樣 build log 內的執行檔路徑都很長會很醜 xd）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=Django-Q Cluster for site pydoc_autobuild
After=syslog.target
Wants=uwsgi.service

[Service]
User=pydoc
Group=www-data
Environment=VIRTUAL_ENV=/path/to/VENV
Environment=PATH=/path/to/VENV/bin:$PATH
Environment=DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production
WorkingDirectory=/path/to/code/pydoc_autobuild
ExecStart=/path/to/VENV/bin/python manage.py qcluster
Restart=always
KillSignal=SIGQUIT
Type=simple
NotifyAccess=none
StandardError=syslog

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣的設定檔應該不是 systemd 的慣例，我還在想是不是應該要改寫到 user service 去（但我不會）。&lt;/p&gt;
&lt;p&gt;加入到 systemd 之後管理就很簡單，啟動這兩個 service：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl enable uwsgi
sudo systemctl enable qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看他們的狀態：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl status uwsgi
sudo systemctl status qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看它們的 log 也變得很簡單，因為有把它們的 stderr 抓起來。systemd 好處是 rotation 等等都會幫你注意，看 log 的功能也很多。&lt;/p&gt;
&lt;p&gt;例如要查最近一小時 uWSGI 的連線記錄，並在有新連線時持續更新 log：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo journalctl -xef -u uwsgi --since &amp;#39;1 hour ago&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_4"&gt;總結&lt;/h2&gt;
&lt;p&gt;介紹了 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件翻譯計畫&lt;/a&gt;，線上文件autobuild server 基於 Django 與 Django-Q 的架構，以及在 Debian 上結合 nginx、uWSGI、systemd 的部署設定。&lt;/p&gt;
&lt;p&gt;查資料時覺得文章還不多，只有幾篇像 &lt;a href="https://luxagraf.net/src/how-set-django-uwsgi-systemd-debian-8"&gt;&lt;em&gt;How to Set Up Django with Nginx, uWSGI &amp;amp; systemd on Debian/Ubuntu&lt;/em&gt;&lt;/a&gt; 的文章，剩下要自己組裝還是要花一點時間。同時也把部署 pydoc server 的設定都記在這，將來要重建也比較簡單。&lt;/p&gt;
&lt;p&gt;關於說明文件翻譯，應該會再花篇文章好好寫整個計畫本身。&lt;/p&gt;
&lt;p&gt;（是說如果有人能從頭看到尾的話，給個回饋吧 &amp;gt; &amp;lt;）&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:zh-Hant"&gt;
&lt;p&gt;八卦是，臺灣繁體中文的 language code (or locale identifier) 究竟是 zh_TW、zh-Hant、zh-Hant-TW、zh-Hant_TW、zh_Hant 還是 zh_Hant_TW？這問題本身就可以寫一篇了。&lt;br&gt;&lt;br&gt;查國際規範 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的話，只有 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant"&gt;zh-Hant&lt;/a&gt; 和 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant-TW"&gt;zh-Hant-TW&lt;/a&gt;，更多關於標準的說明與定義可以參考 &lt;a href="https://www.w3.org/International/articles/bcp47/"&gt;&lt;em&gt;Understanding the New Language Tags&lt;/em&gt;, W3C&lt;/a&gt; 一文。&lt;br&gt;&lt;br&gt;不過現狀是很奇妙的。參考 OSX 定義 &lt;a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html"&gt;&lt;em&gt;Language and Locale IDs&lt;/em&gt;&lt;/a&gt; 的話應該是 zh_TW、zh-Hant 或 zh-Hant_TW。而在 Debain 中，所有支援的 locale 寫在 &lt;code&gt;/usr/share/i18n/SUPPORTED&lt;/code&gt;，裡面只有 zh_TW，不過 Debian 只用 &lt;code&gt;language[_country][.charset]&lt;/code&gt; 所以不會有定義中為 script 的 Hant，雖然在 locale 中使用底線與 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的定義不同。Sphinx 透過 &lt;a href="http://babel.pocoo.org/"&gt;Babel&lt;/a&gt; 處理 locale，但它不允許 locale 中有 &lt;code&gt;-&lt;/code&gt;，因此只能考慮 zh_Hant 或 zh_Hant_TW。更有趣的是，locale 應該是 case-insensitive 所以大小寫是不重要的 XD&amp;#160;&lt;a class="footnote-backref" href="#fnref:zh-Hant" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:pydoc-url"&gt;
&lt;p&gt;其實在 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt; 上面 &lt;a href="https://docs.python.org/3/"&gt;/3/&lt;/a&gt; 和 &lt;a href="https://docs.python.org/3.5/"&gt;/3.5/&lt;/a&gt; 是不同份文件，即使是同個版本號它們更新的時間不相同。蠻意外會是這樣的情況。不過我們不用搞這麼複雜，只要轉址就好。&amp;#160;&lt;a class="footnote-backref" href="#fnref:pydoc-url" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:build-link"&gt;
&lt;p&gt;開發時一直都是用 GET，即如文中所說，有個專屬的 link。但發現會有 robot / crawler 打這些路徑，因此最後改成 POST，把 &lt;code&gt;{{ pagename }}&lt;/code&gt; 用 data-* 即 &lt;code&gt;&amp;lt;a href="#" data-pagename="{{ pagename }}"&amp;gt;...&amp;lt;/a&amp;gt;&lt;/code&gt; 的方式存起來，在用 jQuery 綁定 click listener。&amp;#160;&lt;a class="footnote-backref" href="#fnref:build-link" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:python3"&gt;
&lt;p&gt;看 &lt;a href="https://github.com/coleifer/huey"&gt;huey&lt;/a&gt; 和 &lt;a href="https://github.com/PolicyStat/jobtastic"&gt;jobtastic&lt;/a&gt; master branch 上有 py3k 的 commit 但感覺是最近的事，有待觀察。&amp;#160;&lt;a class="footnote-backref" href="#fnref:python3" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:ec2-nano"&gt;
&lt;p&gt;吐嘈一下，t2.nano vCPU 真的時快時慢，有時 build doc 幾分鐘就搞定了，有時要幾十分鐘，有一天超慢，然後又被 web crawler 抓到，讓 task queue timeout 陷入了 timeout、restart、timeout 的無限地獄……&amp;#160;&lt;a class="footnote-backref" href="#fnref:ec2-nano" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:/run"&gt;
&lt;p&gt;/var/run = /run，這個路徑是個 tmpfs 所以每次重開機就會清空，目錄要記得重建。&amp;#160;&lt;a class="footnote-backref" href="#fnref:/run" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="pydoctw"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category></entry></feed>