<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang-Bo Wang's Blog - postgresql</title><link href="https://blog.liang2.tw/" rel="alternate"></link><link href="https://blog.liang2.tw/feeds/tag_postgresql.atom.xml" rel="self"></link><id>https://blog.liang2.tw/</id><updated>2018-01-20T00:00:00-06:00</updated><entry><title>Ad hoc bioinformatic analysis in database</title><link href="https://blog.liang2.tw/posts/2018/01/ad-hoc-bioinfo-analysis-in-database/" rel="alternate"></link><published>2018-01-20T00:00:00-06:00</published><updated>2018-01-20T00:00:00-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2018-01-20:/posts/2018/01/ad-hoc-bioinfo-analysis-in-database/</id><summary type="html">&lt;p&gt;Recently I&amp;rsquo;ve found that bioinformatic analysis in a database is not hard at all and the database set up wasn&amp;rsquo;t as daunting …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I&amp;rsquo;ve found that bioinformatic analysis in a database is not hard at all and the database set up wasn&amp;rsquo;t as daunting as it sounds, especially when the data are tabular. I used to start my analysis with loading everything into R or Python, and then figuring out all the filtering and grouping commands with my favorite R or Python packages. However, the data size would be bound by memory and the analysis might be slow unless additional optimization was applied. On the other hand, databases have already solved the problems by mapping the data to disk and indexing. Therefore I&amp;rsquo;d like to share my recent experience on using databases for bioinfo analysis.&lt;/p&gt;
&lt;p&gt;Note that if one is interested in the actual tips of using databases for analysis, feel free to skip the whole background section.&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#background"&gt;Background&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#reading-tabular-data-in-bioinformatics"&gt;Reading tabular data in bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#database"&gt;Database&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#tabular-data-io-in-database"&gt;Tabular data IO in database&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sqlite"&gt;SQLite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#loading-compressed-data-with-named-pipe"&gt;Loading compressed data with named pipe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#benchmark"&gt;Benchmark&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pandas-python"&gt;pandas (Python)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sqlite_1"&gt;SQLite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql_1"&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#result"&gt;Result&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="background"&gt;Background&lt;/h2&gt;
&lt;h3 id="reading-tabular-data-in-bioinformatics"&gt;Reading tabular data in bioinformatics&lt;/h3&gt;
&lt;p&gt;Tabular data are everywhere in bioinformatics. To record gene expressions, variants or cross reference IDs between different annotation systems or databases, data are stored in various tabular-like formats, such as BED, GTF, MAF, and VCF, which can usually be normalized to the standard CSV and TSV files. Starting with the raw data, we apply different kinds of filtering and grouping to pick up the records of interest. For example, we might subset the data within a genomic region, select transcripts above an expression threshold, or group the data by the same transcript across multiple samples.&lt;/p&gt;
&lt;p&gt;Researchers have developed numerous tools to select the data of interest. In Python, numpy and pandas dominate the analysis; in R, data.frame, tibble, and data.table are all widely used. However, all the tools above only work if the data can be fit into memory. Unfortunately, bioinformatics data can go beyond 10GB easily these days. It has been difficult to analyze everything in memory. Even using a powerful server with a few hundreds GB of memory, the overhead of loading all data into memory can be time-consuming. To make things worse, when joining multiple data together, the magnitude of the issues above will be multiplied.&lt;/p&gt;
&lt;p&gt;One might argue that in Python there are packages like &lt;a href="http://xarray.pydata.org/en/stable/"&gt;xarray&lt;/a&gt; and &lt;a href="https://dask.pydata.org/en/latest/"&gt;dask&lt;/a&gt; capable of handling out-of-memory multi-dimensional array. But they are only useful for handling numerical data. In bioinformatics, metadata are frequently used and consist of many text columns, where numpy doesn&amp;rsquo;t have the same computing advantage as numerical columns. For example, gene expression only makes sense if it comes with the gene symbol, the transcript id, and the sample id.&lt;/p&gt;
&lt;h3 id="database"&gt;Database&lt;/h3&gt;
&lt;p&gt;Databases have been solving the out-of-memory data analysis for decades, and it also comes with several advantages. First, the language databases use is standardized, known as Structured Query Language (SQL). SQL is expressive, which means instead of writing how to load or query the data, one writes what the data or the query look like. Databases support concurrent reads, enabling query in parallel. Second, One can speed up the queries by setting up indexes. Different types of indexes and different combinations of columns can be added to boost the query. Lastly, databases are persistent, so one only needs to load the data once.&lt;/p&gt;
&lt;p&gt;I mainly use two databases: &lt;a href="https://sqlite.org/"&gt;SQLite&lt;/a&gt; and &lt;a href="https://www.postgresql.org/"&gt;PostgreSQL&lt;/a&gt;. SQLite&amp;rsquo;s database is just a single file on disk and it doesn&amp;rsquo;t need any configuration to run. In fact SQLite ships with Python, available as the &lt;a href="https://docs.python.org/3/library/sqlite3.html"&gt;&lt;code&gt;sqlite&lt;/code&gt; module&lt;/a&gt;. SQLite works very well in my case.&lt;/p&gt;
&lt;p&gt;PostgreSQL is a more feature-rich database and has better concurrency support such as multiple writers at the same time. &lt;a href="https://www.postgresql.org/docs/current/static/indexes-types.html"&gt;Its advanced indexing&lt;/a&gt; and &lt;a href="https://www.postgresql.org/docs/current/static/datatype.html"&gt;data types&lt;/a&gt; might be helpful for genomic range query. The downside is that it requires some configurations and its installation is not as easy as SQLite. Though the basic PostgreSQL setup is actually just a few commands on Debian Linux, one probably needs to go through some documentation to understand what they are about and how to tweak the config.&lt;/p&gt;
&lt;p&gt;The most annoying thing I found using a database in the past was to load my data, where I had to create the table by &lt;code&gt;CREATE TABLE ...&lt;/code&gt; and insert all my data by multiple &lt;code&gt;INSERT INTO ... VALUES ...&lt;/code&gt; statements. But recently I found that many databases have some built-in utilities to make the process easy and fast. Also, it is not hard to programmatically generate the statements through packages like &lt;a href="https://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt;. Therefore, I will share some experience of using databases here.&lt;/p&gt;
&lt;h2 id="tabular-data-io-in-database"&gt;Tabular data IO in database&lt;/h2&gt;
&lt;h3 id="sqlite"&gt;SQLite&lt;/h3&gt;
&lt;p&gt;For SQLite, use &lt;code&gt;.mode csv&lt;/code&gt; with &lt;a href="https://www.sqlite.org/cli.html#csv"&gt;&lt;code&gt;.import&lt;/code&gt; statement&lt;/a&gt; to load in data. SQLite will create the table automatically by using the first row as the column names if the table doesn&amp;rsquo;t exist. One can create the table before the loading to define each column&amp;rsquo;s data type, otherwise, columns are just &lt;code&gt;TEXT&lt;/code&gt; type. &lt;code&gt;.separator&lt;/code&gt; controls the delimiter character SQLite uses between columns.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;csv&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;separator&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;   &lt;span class="c1"&gt;-- For TSV files&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/path/to/tsv&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To export data, use &lt;code&gt;.once&lt;/code&gt; statement followed by the query:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;  &lt;span class="c1"&gt;-- Export columns name&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/path/to/output.tsv&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="k"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- Export all data in the table&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Commands above can be scripted into SQLite like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sqlite3 mydb.sqlite &amp;lt; load_data.sql
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="postgresql"&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;For PostgreSQL, the built-in solution is to use the &lt;a href="https://www.postgresql.org/docs/current/static/sql-copy.html"&gt;&lt;code&gt;COPY&lt;/code&gt; statement&lt;/a&gt; or the &lt;a href="https://www.postgresql.org/docs/current/static/app-psql.html#APP-PSQL-META-COMMANDS-COPY"&gt;&lt;code&gt;\copy&lt;/code&gt; metacommand&lt;/a&gt; to import or export data. &lt;code&gt;COPY&lt;/code&gt; runs faster than the equivalent &lt;code&gt;INSERT&lt;/code&gt; statements. Besides built-in commands, an external tool &lt;a href="https://pgloader.io/"&gt;pgloader&lt;/a&gt; has been very helpful for the data loading, whose loading process is more flexible.&lt;/p&gt;
&lt;p&gt;In this post, I won&amp;rsquo;t dive into details of their usage. There will be an example in the benchmark section.&lt;/p&gt;
&lt;h3 id="loading-compressed-data-with-named-pipe"&gt;Loading compressed data with named pipe&lt;/h3&gt;
&lt;p&gt;Many tabular data are compressed by gzip or bgzip to save the disk space. To decompress the file and load into the database without storing the uncompressed file somewhere first, one can consider using &lt;a href="https://www.linuxjournal.com/article/2156"&gt;named pipe&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea is to decompress the file to a named pipe and read the data in a database from the named pipe. A named pipe can be created by &lt;code&gt;mkfifo&lt;/code&gt;.  For example,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkfifo mypipe
gunzip -c mydata.tsv.gz &amp;gt; mypipe &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The trailing &lt;code&gt;&amp;amp;&lt;/code&gt; makes the decompress command running in the background to keep everything in one shell session. Then read the data in SQLite as if it were a file like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;mypipe&lt;/span&gt; &lt;span class="nn"&gt;mytable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The trick here can be further expanded to any preprocessing in any language. One can simply preprocess the file and write the output to a named pipe. The database can read from the named pipe without storing the full intermediate output on disk. Plus, by piping between commands more CPU cores are utilized.&lt;/p&gt;
&lt;h2 id="benchmark"&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;To give an idea of the data processing time in databases, I used all the &lt;a href="https://www.synapse.org/#!Synapse:syn7214402/wiki/405297"&gt;somatic variants from TCGA MC3&lt;/a&gt; as a demonstration. The goal here is to count the number of variants by different transcript and its mutation type. So the output result will be something like the following:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Transcript ID&lt;/th&gt;
&lt;th&gt;Mutation type&lt;/th&gt;
&lt;th&gt;Count&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ENST00000000233&lt;/td&gt;
&lt;td&gt;3&amp;rsquo;UTR&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ENST00000000233&lt;/td&gt;
&lt;td&gt;Frame_Shift_Del&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ENST00000000233&lt;/td&gt;
&lt;td&gt;Intron&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;After filtering out all the silent mutations, there are about total 2.8 million variants making up 614MB of disk space.&lt;/p&gt;
&lt;p&gt;I used three methods to load and group the variants: pandas, SQLite, and PostgreSQL. Their code is shown below.&lt;/p&gt;
&lt;h3 id="pandas-python"&gt;pandas (Python)&lt;/h3&gt;
&lt;p&gt;Standard pandas IO code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pd&lt;/span&gt;


&lt;span class="n"&gt;df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;mc3_filtered.tsv&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;chrom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;strand&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;mutation_type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;ref_allele&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;alt_allele&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;transcript_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;hgvs_c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hgvs_p&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cdna_start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cdna_end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;p_start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;p_end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;normal_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tumor_id&amp;#39;&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;chrom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;strand&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cdna_start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;cdna_end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;p_start&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;p_end&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;grp_df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;transcript_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;mutation_type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;alt_allele&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset_index&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;grp_df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;out.pandas.tsv&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="sqlite_1"&gt;SQLite&lt;/h3&gt;
&lt;p&gt;I set some &lt;code&gt;PRAGMA ...&lt;/code&gt; statements at the beginning to control some of the SQLite settings. It tells SQLite to use more cache, create temporary tables in memory and disable all the transaction recovery settings. SQLite by default writes everything to the disk first before changing the actual database content so if the program fails or any exception occurs, it can recover all the transactions properly. In our case, we don&amp;rsquo;t care about the integrity of the database.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;cache_size&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;4192000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- Use 2GB RAM as cache&lt;/span&gt;
&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;temp_store&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;MEMORY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;synchronous&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;OFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;journal_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;OFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PRAGMA&lt;/span&gt; &lt;span class="n"&gt;locking_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;EXCLUSIVE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;csv&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;separator&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;mc3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;chrom&lt;/span&gt;       &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="ss"&gt;&amp;quot;start&amp;quot;&lt;/span&gt;     &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="ss"&gt;&amp;quot;end&amp;quot;&lt;/span&gt;       &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;strand&lt;/span&gt;      &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;mutation_type&lt;/span&gt;   &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;ref_allele&lt;/span&gt;  &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;alt_allele&lt;/span&gt;  &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;transcript_id&lt;/span&gt;   &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;hgvs_c&lt;/span&gt;      &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;hgvs_p&lt;/span&gt;      &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;cdna_start&lt;/span&gt;  &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;cdna_end&lt;/span&gt;    &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;p_start&lt;/span&gt;     &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;p_end&lt;/span&gt;       &lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;normal_id&lt;/span&gt;   &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;tumor_id&lt;/span&gt;    &lt;span class="nb"&gt;TEXT&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;mc3_filtered&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tsv&lt;/span&gt; &lt;span class="n"&gt;mc3&lt;/span&gt;
&lt;span class="c1"&gt;-- Create an index to speed up grouping on the same columns&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;mc3_idx&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;mc3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transcript_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutation_type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;-- Output&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqlite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tsv&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;transcript_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutation_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;alt_allele&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;mc3&lt;/span&gt;
&lt;span class="k"&gt;GROUP&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;transcript_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutation_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="postgresql_1"&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;I used &lt;a href="https://pgloader.io/"&gt;pgloader&lt;/a&gt; to load the data into a local PostgreSQL database &lt;code&gt;test_mc3&lt;/code&gt;. pgloader can take a script of its own mini-language.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;LOAD CSV
    FROM &amp;#39;mc3_filtered.tsv&amp;#39;
    INTO postgresql:///test_mc3?mc3
    WITH fields terminated by &amp;#39;\t&amp;#39;,
         fields not enclosed,
         drop indexes
    BEFORE LOAD DO
    $$ DROP TABLE IF EXISTS mc3; $$,
    $$ CREATE TABLE mc3 (
            chrom       TEXT,
            &amp;quot;start&amp;quot;     BIGINT,
            &amp;quot;end&amp;quot;       BIGINT,
            strand      SMALLINT,
            mutation_type   TEXT,
            ref_allele  TEXT,
            alt_allele  TEXT,
            transcript_id   TEXT,
            hgvs_c      TEXT,
            hgvs_p      TEXT,
            cdna_start  INT,
            cdna_end    INT,
            p_start     INT,
            p_end       INT,
            normal_id   TEXT,
            tumor_id    TEXT
        );
    $$,
    $$ CREATE INDEX mc3_idx ON mc3 (transcript_id, mutation_type); $$
;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To do the grouping analysis, I used the built-in &lt;code&gt;COPY&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;COPY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;transcript_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutation_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;alt_allele&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;mc3&lt;/span&gt;
    &lt;span class="k"&gt;GROUP&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;transcript_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutation_type&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/private/tmp/mc3/MC3/out.psql.tsv&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FORMAT&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="result"&gt;Result&lt;/h3&gt;
&lt;p&gt;I didn&amp;rsquo;t run it systematically but a few repeats showed the similar numbers.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Method&lt;/th&gt;
&lt;th align="right"&gt;Read data (sec)&lt;/th&gt;
&lt;th align="right"&gt;Group-by analysis (sec)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Pandas&lt;/td&gt;
&lt;td align="right"&gt;10.7&lt;/td&gt;
&lt;td align="right"&gt;0.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;SQLite&lt;/td&gt;
&lt;td align="right"&gt;27.7&lt;/td&gt;
&lt;td align="right"&gt;4.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;PostgreSQL&lt;/td&gt;
&lt;td align="right"&gt;82.6&lt;/td&gt;
&lt;td align="right"&gt;13.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In this case, all data can be loaded into memory easily, so pandas gave the best performance here. It actually took nearly no-time to complete the grouping.&lt;/p&gt;
&lt;p&gt;All databases ran much slower on loading data than pandas. PostgreSQL seems to run a lot more slower than SQLite, which I think it has something to do with my server configuration, say, not enough cache size, or not enough working memory for the group-by operation. I feel like PostgreSQL can be faster but anyway this&amp;rsquo;s the result I have so far. Note that all the databases are stored on a PCIe SSD disk. If they were on a normal hard drive, the database creation will take a much longer time.&lt;/p&gt;
&lt;p&gt;However, after the data are loaded into the database, the speed of the query alone is comparable to pandas. Because for pandas, one cannot skip the step of reading data so if the analysis is on a frequently used dataset, database like SQLite can yield better performance. Once the data get larger than the memory capacity, special care will be needed to make the pandas&amp;rsquo; approach work, whereas database can scale up with little fuss.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;My post provides a different solution to work with tabular data by working in a database. In-memory approaches like pandas work very efficiently at a small dataset but one will have to code the &amp;ldquo;how-tos&amp;rdquo; to scale to a larger dataset that cannot feed into memory (or the overhead is too high). On the other hand, databases can easily scale to a few hundred GBs in size and the query is fast. For analysis on a frequently used dataset, loading data into the database first might be a good idea.&lt;/p&gt;
&lt;p&gt;Another good thing about databases is that SQL makes joining across tables easily. One can easily join across multiple tables, say, expand the gene annotation and doesn&amp;rsquo;t have to worry how to implement it. With indexing, the joining can be fast. In pandas, one generates many objects representing the joining results, but those objects cannot be easily shared between scripts. Relying on storing the intermediate objects on disk, the accumulated overhead might be significant. Projects like &lt;a href="https://arrow.apache.org/"&gt;Apache Arrow&lt;/a&gt; might solve the in-memory object passing ultimately, but its development is still in the early phase. As for databases, one can define reusable views for the joining logic and filtering results. The post didn&amp;rsquo;t really touch this part so I probably need another benchmark or post to back my thoughts.&lt;/p&gt;
&lt;p&gt;If one is analyzing variants, using databases or SQL in general has been backed up by many pratical projects. People at &lt;a href="http://quinlanlab.org/"&gt;Quinlab Lab&lt;/a&gt; hace been building &lt;a href="https://github.com/quinlan-lab/vcf2db"&gt;vcf2db&lt;/a&gt; to load variants into databases for downstream annotation and analysis. To scale way up to terabytes or petabytes of variant data, &lt;a href="https://cloud.google.com/genomics/v1/analyze-variants"&gt;Google Cloud Genomics&lt;/a&gt; provides an interface to store and query variants in BigQuery, where users use standard SQL to select the variants of interest.&lt;/p&gt;
&lt;p&gt;However, working in pandas gives users great room for flexibility. For example, one can iterate over rows and do some complex transformation of the value. Maybe it would be the optimal solution to use &lt;a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql.html#pandas.read_sql"&gt;&lt;code&gt;pandas.read_sql&lt;/code&gt;&lt;/a&gt; to run a query in a database.&lt;/p&gt;
&lt;p&gt;It seems to me like many people rely too much on the features of some special file formats such as bgzip and tabix and have forgotten the generic yet flexible approach using databases. Those formats often optimize the random access by a given genomic query by indexing. In databases, such index is analogous to &lt;code&gt;(chrom, start, -end)&lt;/code&gt; or even GiST index on Range type in PostgreSQL. It might be slower in databases, but aside from the performance, one can continue to query the records in the same way in databases. For special format, the functionality will be much limited.&lt;/p&gt;
&lt;p&gt;Now I will give the database approach a try before writing my own data wrangling script.&lt;/p&gt;
&lt;p&gt;EDIT 2018-01-28: Add real world examples of using databases to store variant data.&lt;/p&gt;</content><category term="en"></category><category term="python"></category><category term="pandas"></category><category term="sqlite"></category><category term="postgresql"></category></entry><entry><title>使用 conda env 部署 Django</title><link href="https://blog.liang2.tw/posts/2016/05/django-deploy-conda/" rel="alternate"></link><published>2016-05-24T00:00:00-05:00</published><updated>2016-05-24T00:00:00-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-05-24:/posts/2016/05/django-deploy-conda/</id><summary type="html">&lt;p&gt;沒幾天前剛部署一次 Django，記錄在&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;《使用 uWSGI、nginx、systemd 部署 Django》&lt;/a&gt;。今天又部署了另一個專案。部署的設定跟上次一樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一樣寫一個 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理網站的啟動 (uWSGI …&lt;/p&gt;</summary><content type="html">&lt;p&gt;沒幾天前剛部署一次 Django，記錄在&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;《使用 uWSGI、nginx、systemd 部署 Django》&lt;/a&gt;。今天又部署了另一個專案。部署的設定跟上次一樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一樣寫一個 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理網站的啟動 (uWSGI)。之後提到 &lt;code&gt;PROJ&lt;/code&gt; 時就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#conda"&gt;conda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi-path"&gt;uWSGI 和 $PATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sysmted-unit"&gt;在 sysmted unit 使用環境變數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;結論&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="conda"&gt;conda&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://conda.pydata.org/"&gt;conda&lt;/a&gt; 是一個 Python 套件的管理系統，他的好處是，遇到要使用外部 library 時，會這些套件相依的 library 都一併安裝管理，也可以管理不同 Python 版本。可以想像是加強版的 pip + venv。conda 跟 pip 是相容的。&lt;/p&gt;
&lt;p&gt;這個 Django 專案就用到很多像 numpy、pandas 的套件。為了維護方便，我考慮用 conda 來安裝。我使用的是 &lt;a href="http://conda.pydata.org/miniconda.html"&gt;miniconda3&lt;/a&gt;，預設會安裝在 &lt;code&gt;~/miniconda3&lt;/code&gt; 底下，虛擬環境會出現在 &lt;code&gt;~/miniconda3/envs/&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ conda create -n VENV &lt;span class="nv"&gt;python&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.5 numpy pandas django
$ &lt;span class="nb"&gt;source&lt;/span&gt; activate VENV
&lt;span class="o"&gt;(&lt;/span&gt;VENV&lt;span class="o"&gt;)&lt;/span&gt; $ pip install uwsgi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uWSGI 沒有在 conda 裡面，所以就用 pip 裝。從&lt;a href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/"&gt;上次的文章&lt;/a&gt;知道系統並不用安裝。&lt;/p&gt;
&lt;h3 id="uwsgi-path"&gt;uWSGI 和 $PATH&lt;/h3&gt;
&lt;p&gt;理論上，之後就照著上次操作就好，但在 uWSGI 就碰到問題：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;$ sudo /home/USER/miniconda3/envs/VENV/bin/uwsgi --ini PROJ.ini&lt;/span&gt;
&lt;span class="go"&gt;[uWSGI] getting INI configuration from PROJ.ini&lt;/span&gt;
&lt;span class="go"&gt;*** Starting uWSGI 2.0.13.1 (64bit) on [Wed May 25 08:04:23 2016] ***&lt;/span&gt;
&lt;span class="go"&gt;compiled with version: 5.3.1 20160413 on 25 May 2016 01:35:28&lt;/span&gt;
&lt;span class="go"&gt;os: Linux-4.4.0-22-generic #40-Ubuntu SMP Thu May 12 22:03:46 UTC 2016&lt;/span&gt;
&lt;span class="go"&gt;nodename: s66&lt;/span&gt;
&lt;span class="go"&gt;machine: x86_64&lt;/span&gt;
&lt;span class="go"&gt;clock source: unix&lt;/span&gt;
&lt;span class="go"&gt;detected number of CPU cores: 24&lt;/span&gt;
&lt;span class="go"&gt;current working directory: /etc/uwsgi/vassals&lt;/span&gt;
&lt;span class="go"&gt;detected binary path: /home/USER/miniconda3/envs/VENV/bin/uwsgi&lt;/span&gt;
&lt;span class="go"&gt;……&lt;/span&gt;
&lt;span class="go"&gt;chdir() to /path/to/PROJ/&lt;/span&gt;
&lt;span class="go"&gt;your processes number limit is 514650&lt;/span&gt;
&lt;span class="go"&gt;your memory page size is 4096 bytes&lt;/span&gt;
&lt;span class="go"&gt;detected max file descriptor number: 1024&lt;/span&gt;
&lt;span class="go"&gt;lock engine: pthread robust mutexes&lt;/span&gt;
&lt;span class="go"&gt;thunder lock: disabled (you can enable it with --thunder-lock)&lt;/span&gt;
&lt;span class="go"&gt;uwsgi socket 0 bound to UNIX address /run/PROJ/django.sock fd 3&lt;/span&gt;
&lt;span class="go"&gt;Python version: 3.5.1 |Continuum Analytics, Inc.| (default, Dec  7 2015, 11:16:01)  [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]&lt;/span&gt;
&lt;span class="go"&gt;Set PythonHome to /home/USER/miniconda3/envs/VENV&lt;/span&gt;
&lt;span class="go"&gt;Failed to import the site module&lt;/span&gt;
&lt;span class="gt"&gt;Traceback (most recent call last):&lt;/span&gt;
  File &lt;span class="nb"&gt;&amp;quot;/usr/lib/python3.5/site.py&amp;quot;&lt;/span&gt;, line &lt;span class="m"&gt;580&lt;/span&gt;, in &lt;span class="n"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gr"&gt;  …… &lt;/span&gt;
&lt;span class="gr"&gt;  File &amp;quot;/usr/lib/python3.5/_sysconfigdata.py&amp;quot;, line 6, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="gr"&gt;    from _sysconfigdata_m import *&lt;/span&gt;
&lt;span class="gr"&gt;ImportError&lt;/span&gt;: &lt;span class="n"&gt;No module named &amp;#39;_sysconfigdata_m&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但因為步驟實在太簡單，想不出來哪裡有錯，查網路也沒什麼相關的結果。在這邊卡了很久。&lt;/p&gt;
&lt;p&gt;結果後來才發現，Traceback 那邊 uWSGi 跑去讀到 &lt;code&gt;/usr/lib/python3.5/site.py&lt;/code&gt;，這表示一定有環境設錯才讓它找到這個不是我們要的 python 環境，理論上應該是找到 &lt;code&gt;/home/USER/miniconda3/envs/VENV/lib/python3.5/site.py&lt;/code&gt; 才對。&lt;/p&gt;
&lt;p&gt;經過一陣嘗試，發現只要修改 &lt;code&gt;$PATH&lt;/code&gt; 環境變數就能運作了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -i
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;span class="go"&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/home/USER/miniconda3/envs/VENV/bin:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; /home/USER/miniconda3/envs/VENV/bin/uwsgi --ini PROJ.ini
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="sysmted-unit"&gt;在 sysmted unit 使用環境變數&lt;/h3&gt;
&lt;p&gt;根據 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#%24PATH"&gt;systemd.exec(5)&lt;/a&gt; 關於 &lt;code&gt;$PATH&lt;/code&gt; 環境變數的使用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Colon-separated list of directories to use when launching executables. Systemd uses a fixed value of /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;預設只有以上提到的路徑，如果要修改環境變數的話，就透過 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Environment="&gt;&lt;code&gt;Environment=&lt;/code&gt;&lt;/a&gt;，因此多加了一行在 systemd unit 裡。其餘的設定都是相同的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PROJ Django server by uWSGI&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog.target&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PATH=/home/USER/miniconda3/envs/VENV/bin:$PATH&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/home/USER/miniconda3/envs/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;KillSignal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;SIGQUIT&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;notify&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;
&lt;span class="na"&gt;NotifyAccess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;all&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_1"&gt;結論&lt;/h3&gt;
&lt;p&gt;如果要改用 conda 管理套件的話，只要在 systemd unit 那邊多加一行修改 $PATH，加入虛擬環境放執行檔的路徑，其餘的設定都與一般 Python 虛擬環境相同。這樣就搞定了。但這個問題花了我 1 個多小時……&lt;/p&gt;</content><category term="zh"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category><category term="conda"></category></entry><entry><title>使用 uWSGI、nginx、systemd 部署 Django</title><link href="https://blog.liang2.tw/posts/2016/05/django-deploy-uwsgi-nginx-systemd/" rel="alternate"></link><published>2016-05-19T00:00:00-05:00</published><updated>2016-05-19T00:00:00-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-05-19:/posts/2016/05/django-deploy-uwsgi-nginx-systemd/</id><summary type="html">&lt;p&gt;上一次很認真的 Django 部署記錄在&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;《設定 Python 官方文件中文化自動更新 Server》&lt;/a&gt;一文。很巧地自己畢業的題目也要架個 Django 網站，所以就再跑了一次部署設定。舊文還提了有的沒的，這篇僅針對 Django 的部署。&lt;/p&gt;
&lt;p&gt;這邊的部署設定都儘量不使用 root 權限，整個連線的流程圖如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nginx -- unix socket -- uWSGI …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;上一次很認真的 Django 部署記錄在&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;《設定 Python 官方文件中文化自動更新 Server》&lt;/a&gt;一文。很巧地自己畢業的題目也要架個 Django 網站，所以就再跑了一次部署設定。舊文還提了有的沒的，這篇僅針對 Django 的部署。&lt;/p&gt;
&lt;p&gt;這邊的部署設定都儘量不使用 root 權限，整個連線的流程圖如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nginx -- unix socket -- uWSGI -- Django
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;寫一個名為 &lt;code&gt;PROJ.service&lt;/code&gt; 的 systemd unit 來管理這網站的啟動與否。之後 &lt;code&gt;PROJ&lt;/code&gt; 就換成自己的專案名稱；&lt;code&gt;USER&lt;/code&gt; 就換成執行網站的帳號。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;作業系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-proj"&gt;Django PROJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd"&gt;systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;確認、總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;使用 Ubuntu 16.04 LTS。我對 Ubuntu 其實沒愛，但因為很多人用，畢業之後應該還找得到人維護。他跟 Debian 差不多，所以跟舊文沒什麼差別。Ubuntu 16 內建就有 Python 3.5，不用再裝；PostgreSQL 也來到 9.5 版。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href="https://wiki.debian.org/UnattendedUpgrades"&gt;unattended-upgrades&lt;/a&gt; 定期更新與 security 相關的套件，它預設一天檢查一次，更新的記錄會在 &lt;code&gt;/var/log/unattended-upgrades&lt;/code&gt; 目錄中。&lt;/p&gt;
&lt;h3 id="postgresql"&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;參考&lt;a href="https://blog.liang2.tw/posts/2016/01/postgresql-install/"&gt;《安裝 PostgreSQL 9 於 Debian Jessie / OSX》&lt;/a&gt;一文設定。建立跟 OS user 同名的 PostgreSQL 帳號，給了建立 database 的權限，這樣開發比較方便。不用設定密碼。&lt;/p&gt;
&lt;h3 id="django-proj"&gt;Django PROJ&lt;/h3&gt;
&lt;p&gt;使用內建 &lt;a href="https://docs.python.org/3/library/venv.html"&gt;venv&lt;/a&gt; 在自己家目錄下某處，建立名為 &lt;code&gt;VENV&lt;/code&gt; 的虛擬環境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3.5 -m venv VENV
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有關部署的設定（即 &lt;code&gt;settings.py&lt;/code&gt;），利用 &lt;a href="https://github.com/joke2k/django-environ"&gt;django-environ&lt;/a&gt; 把 secret key、database 連線資訊、寄信 SMTP server 等設定寫在獨立的檔案，就可以讓 local 和 production 環境讀到各自的設定。具體的做法可以參考 &lt;a href="https://github.com/pycontw/pycontw2016/blob/master/src/pycontw2016/settings/production.py"&gt;PyCon Taiwan 2016 網站管理設定&lt;/a&gt; 的寫法。&lt;/p&gt;
&lt;p&gt;在連 PostgreSQL 時使用 local connection (Unix-domain socket)，即使用者同名的身份。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;DATABASE_URL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;postgres:///TABLE_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="tmpfilesd"&gt;tmpfiles.d&lt;/h3&gt;
&lt;p&gt;把 nginx 與 uwsgi 溝通用的 socket 放在 &lt;code&gt;/run/PROJ&lt;/code&gt; 底下，但這也表示重開機之後，&lt;code&gt;/run/PROJ&lt;/code&gt; 資料夾就會消失不見，所以使用 &lt;a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles.d&lt;/a&gt;&lt;sup id="fnref:systemd-runtimedir"&gt;&lt;a class="footnote-ref" href="#fn:systemd-runtimedir"&gt;1&lt;/a&gt;&lt;/sup&gt;。除了資料夾的命名改成用專案名稱，設定都跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;一樣。&lt;/p&gt;
&lt;h3 id="nginx"&gt;nginx&lt;/h3&gt;
&lt;p&gt;nginx 設定跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;一樣。放在 &lt;code&gt;/etc/nginx/sites-available/PROJ.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Upstream Django setting; the socket nginx connects to&lt;/span&gt;
&lt;span class="k"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;django&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:///run/PROJ/django.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;default&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="s"&gt;.123.123.123&lt;/span&gt;
                &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;charset&lt;/span&gt;     &lt;span class="s"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="s"&gt;10M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# max upload size&lt;/span&gt;
    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/static&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/PROJ/assets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Finally, send all non-media requests to the Django server.&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt;  &lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;include&lt;/span&gt;     &lt;span class="s"&gt;/etc/nginx/uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;/path/to/PROJ/assets&lt;/code&gt; 是 Django &lt;a href="https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-STATIC_ROOT"&gt;STATIC_ROOT&lt;/a&gt; 的路徑。只要執行 &lt;code&gt;python manage.py collectstatic&lt;/code&gt; 後，即使 uWSGI 還沒設定就可以測試 /static/&amp;hellip;/ 有沒有被 nginx 抓到。 &lt;/p&gt;
&lt;p&gt;啟動時，先把檔案連結到 &lt;code&gt;/etc/nginx/site-enabled/&lt;/code&gt;，重載 nginx 設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/nginx/sites-enabled/
sudo ln -s ../sites-available/PROJ.conf .
sudo systemctl reload nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="uwsgi"&gt;uWSGI&lt;/h3&gt;
&lt;p&gt;跟舊文最大的差別，只要裝在 VENV 裡面就好了；然後也不使用 emperor mode。寫一個 &lt;code&gt;/etc/uwsgi/vassals/PROJ.ini&lt;/code&gt; 放設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;chdir&lt;/span&gt;        &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/PROJ&lt;/span&gt;
&lt;span class="c1"&gt;# Django&amp;#39;s wsgi file&lt;/span&gt;
&lt;span class="na"&gt;module&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;PROJ.wsgi:application&lt;/span&gt;
&lt;span class="na"&gt;env&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;DJANGO_SETTINGS_MODULE=PROJ.settings.production&lt;/span&gt;
&lt;span class="c1"&gt;# the virtualenv (full path)&lt;/span&gt;
&lt;span class="na"&gt;home&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/VENV&lt;/span&gt;

&lt;span class="c1"&gt;# process-related settings&lt;/span&gt;
&lt;span class="c1"&gt;# master&lt;/span&gt;
&lt;span class="na"&gt;master&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="c1"&gt;# maximum number of worker processes&lt;/span&gt;
&lt;span class="na"&gt;processes&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;4&lt;/span&gt;
&lt;span class="c1"&gt;# the socket (use the full path to be safe&lt;/span&gt;
&lt;span class="na"&gt;socket&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/run/PROJ/django.sock&lt;/span&gt;
&lt;span class="c1"&gt;# ... with appropriate permissions - may be needed&lt;/span&gt;
&lt;span class="na"&gt;chmod-socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;664&lt;/span&gt;
&lt;span class="na"&gt;uid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;USER&lt;/span&gt;
&lt;span class="na"&gt;gid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;www-data&lt;/span&gt;
&lt;span class="c1"&gt;# clear environment on exit&lt;/span&gt;
&lt;span class="na"&gt;vacuum&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;設定好後執行以下指令，就應該能看到網站能動了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /path/to/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="systemd"&gt;systemd&lt;/h3&gt;
&lt;p&gt;這邊除了執行 uWSGI 的指令不同外，都跟&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;舊文&lt;/a&gt;相同。Debian 系 systemd system unit 設定檔放在 &lt;code&gt;/etc/systemd/system/PROJ.service&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PROJ&amp;#39;s Django server by uWSGI&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog.target&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/path/to/VENV/bin/uwsgi --ini /etc/uwsgi/vassals/PROJ.ini&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;KillSignal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;SIGQUIT&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;notify&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;
&lt;span class="na"&gt;NotifyAccess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;all&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這邊設定它會（有錯誤時）自動重新起動，並把 stderr 導到 syslog。接著，就要啟動這個 &lt;code&gt;PROJ.service&lt;/code&gt; 服務：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo systemctl &lt;span class="nb"&gt;enable&lt;/span&gt; PROJ
sudo systemctl status PROJ
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以透過 &lt;code&gt;sudo journalctl -xe -u PROJ&lt;/code&gt; 來查看 uWSGI 執行、連線 log。&lt;/p&gt;
&lt;h3 id="_2"&gt;確認、總結&lt;/h3&gt;
&lt;p&gt;重啟系統一次，如果網站還活著，就表示一切設定都沒問題。整體上不太複雜，但權限不符的錯誤可能會讓你鬼打牆，要有耐心。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:systemd-runtimedir"&gt;
&lt;p&gt;也可以用 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html"&gt;systemd.exec(5)&lt;/a&gt; 提到的 &lt;code&gt;RuntimeDirectory=PROJ&lt;/code&gt; 來建立執行用目錄。但因為 &lt;code&gt;PROJ.service&lt;/code&gt; 的 USER 必須是 root，這種情況 man page 就建議改用 tmpfiles.d。我覺得應該能解決使用 root 權限的問題，但太懶了就先這樣……&amp;#160;&lt;a class="footnote-backref" href="#fnref:systemd-runtimedir" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="zh"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category></entry><entry><title>設定 Python 官方文件中文化自動更新 Server</title><link href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/" rel="alternate"></link><published>2016-02-14T21:00:00-06:00</published><updated>2016-02-14T21:00:00-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-02-14:/posts/2016/02/pydoctw-server/</id><summary type="html">&lt;p&gt;設定一個自動更新 Python 說明文件中文翻譯並且 host 中文化網頁版文件的 server。使用 Django 作 web server、Django-Q 做為 task queue，deploy stack 用 nginx、uWSGI，host 於 Amazon EC2 (Debian Jessie)，資料庫用 PostgreSQL，並用 systemd 管理相關的 process。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt; 可至 &lt;a href="http://docs.python.org.tw"&gt;http://docs.python.org.tw&lt;/a&gt; 看線上自動更新的&lt;a href="http://docs.python.org.tw/3/"&gt;中文化的文件&lt;/a&gt;和 &lt;a href="http://docs.python.org.tw/_build/"&gt;build server&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;EDIT 2016-02-16: 加上 language code、git sshconfig、swap 的設定；文句潤飾。&lt;br&gt;
EDIT 2016-02-20: 加上 tmpfiles.d 的設定。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx"&gt;Sphinx 文件多國語言架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;翻譯體驗改善&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;實作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx_1"&gt;Sphinx 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-django-server"&gt;Autobuild Django server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-server"&gt;Autobuild server 部署&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;作業系統&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;資料庫 PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#swap"&gt;Swap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-repo-ssh-config"&gt;Git repo ssh config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI 設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd-services"&gt;Systemd services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="python"&gt;Python 說明文件中文翻譯計畫&lt;/h2&gt;
&lt;p&gt;最近一段時間都在準備 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;。翻譯本身雖然還沒很積極地進行，但經過&lt;a href="http://www.meetup.com/Taipei-py/events/226558484/"&gt;前&lt;/a&gt;&lt;a href="http://www.meetup.com/Taipei-py/events/227001232/"&gt;幾次&lt;/a&gt; Taipei.py Projects On 的 sprint 活動，已經有蠻多人加入翻譯的行列。大家都有各自翻譯的主題，像我自己是從 &lt;a href="http://docs.python.org.tw/3/tutorial/index.html"&gt;Tutorial&lt;/a&gt; 的部份開始翻譯。&lt;/p&gt;
&lt;h3 id="sphinx"&gt;Sphinx 文件多國語言架構&lt;/h3&gt;
&lt;p&gt;先簡介一下 &lt;a href="https://docs.python.org/3/"&gt;CPython Documentation&lt;/a&gt;（下稱 pydoc）的架構和翻譯方式。pydoc 是標準的 &lt;a href="http://www.sphinx-doc.org/en/stable/"&gt;Sphinx&lt;/a&gt; 文件，因此翻譯使用 Sphinx 自帶的 &lt;a href="http://www.sphinx-doc.org/en/stable/intl.html"&gt;internationalization&lt;/a&gt; (i18n or intl) 功能把文件的內容轉換到別的語言上。&lt;/p&gt;
&lt;p&gt;如同 Django 等專案，i18n 都是透過 gettext，Sphinx 會按照 rst 檔案輸出同檔名的 po 檔。rst 檔案中的每個文字段落會對應到 po 檔一個 entry，不相干的程式碼範例等段落會被跳過。輸出的 po 檔放在對應的路徑例如 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/LC_MESSAGES/xxx.po&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Gettext"&gt;po 檔的格式&lt;/a&gt;很簡單，跳過有的沒的 header，實質內容長這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;#: ../../tutorial/appetite.rst:50&lt;/span&gt;
&lt;span class="nv"&gt;msgid&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python enables programs to be written compactly and readably.  Programs &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;written in Python are typically much shorter than equivalent C,  C++, or &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Java programs, for several reasons:&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;msgstr&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python 讓程式寫得精簡並易讀。用 Python 實作的程式長度往往遠比用 &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;C、C++、Java 實作的短。這有以下幾個原因：&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;實際上 Sphinx 會先輸出一份乾淨的 po 檔範本（稱為 pot 檔）到 &lt;code&gt;locale/pot/&lt;/code&gt;，基本上就是只有原文的 po 檔。每增加一個新語言就會從 pot 檔製作一份 po 檔到各自的 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/&lt;/code&gt; 目錄下，翻譯時就修改那份 po 檔就可以。&lt;/p&gt;
&lt;p&gt;翻譯完成後，首先 Sphinx 會先呼叫 gettext 把 po 檔編譯成 mo 檔加速搜尋翻譯字串速度。輸出翻譯後的文件只要設定不同語言，Sphinx 就會去找該語言的 mo 檔，並把原文字串換成 mo 檔裡的內容，就可以看到中文的文件。&lt;/p&gt;
&lt;h3 id="transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/h3&gt;
&lt;p&gt;整個 Sphinx 文件翻譯流程就這樣，所以翻譯只要編輯中文 (lang code: zh-Hant&lt;sup id="fnref:zh-Hant"&gt;&lt;a class="footnote-ref" href="#fn:zh-Hant"&gt;1&lt;/a&gt;&lt;/sup&gt;) 的 po 檔就好了。不過要直接寫 po 檔格式門檻還是太高，於是就有像 &lt;a href="https://www.transifex.com/"&gt;Transifex&lt;/a&gt; 這樣的網站。上傳 po/pot 檔就能線上修改翻譯，然後再把翻完的結果用 po 檔格式下載下來。我認為這是現在參加以 gettext-based PO 檔翻譯門檻最低的方式，至少日本也是這麼做。於是想要參考 pydoc 翻譯的人，只要登入 Transifex 就可以開始編輯。&lt;/p&gt;
&lt;p&gt;用 Transifex 還有額外的好處。例如他有 POS tagging 可以標注專有名詞，定義統一的譯名，這些譯名會整理在 glossary terms 裡，翻譯時出現這些詞就會自動提示。類似的原文文句也會放在 suggestion 裡，讓翻譯完的用語文法也能一致。此外也有修改歷史、防呆提示（如該有的格式沒在譯文出現）、加註解 (comment)、評論 (issue) 等功能。&lt;/p&gt;
&lt;h3 id="_1"&gt;翻譯體驗改善&lt;/h3&gt;
&lt;p&gt;這段時間翻譯的用詞、流程等規範都有個雛型了，相關的內容都可以在&lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki"&gt;專案的 wiki&lt;/a&gt; 裡找到。所以開始想要怎麼讓大家更好參與翻譯和看到翻譯的結果。&lt;/p&gt;
&lt;p&gt;我發現參加翻譯本身已經不困難，大家沒什麼疑問。維護整體的用詞、翻譯討論用 Transifex issue 和 comment 效果不錯。整體上能保持極度分散式的工作形式。&lt;/p&gt;
&lt;p&gt;平常遇到最多問題是出現 rst 格式錯誤、缺少必要的空白、前後文加上程式碼範例之後不通順、譯文曲解或誤會原文的意思。這些問題，我覺得只要自己讀過翻完的 pydoc 該頁、看一下輸出的 log 就能明白，也不需要我多作解釋。&lt;/p&gt;
&lt;p&gt;再來，看不到自己翻譯的成果&lt;strong&gt;很沒有成就感&lt;/strong&gt;，過一段時間我怕會失去動力。&lt;/p&gt;
&lt;p&gt;於是變成需要一份保持更新的翻譯成果。當然自己輸出 doc 的方法都有寫在 &lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki/How-to-build-the-doc-locally"&gt;wiki&lt;/a&gt; 裡，但步驟很多，說簡單也沒多簡單，而且有錯或有問題可能都要來找我，就失去分散式分工的特性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不如做個 autobuild server。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;於是有了這想法。但實在是個大坑，一直只能用想的。在過年的時候總算找到時間把 prototype 做出來了，其實蠻有成就感的。&lt;/p&gt;
&lt;h2 id="pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/h2&gt;
&lt;p&gt;簡單整理幾個需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyDoc 結果網址對應本家 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt;。例如 /3/ 就是 Python 3.x 版最新的，而現在 /3.5/ 就會自動轉址到 /3/&lt;sup id="fnref:pydoc-url"&gt;&lt;a class="footnote-ref" href="#fn:pydoc-url"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;每一頁都有個更新翻譯連結，點一下就會從 Transifex 上抓新的翻譯，並更新輸出。&lt;/li&gt;
&lt;li&gt;更新每頁翻譯的指令輸出都要保留，方便檢查 rst 語法等錯誤。&lt;/li&gt;
&lt;li&gt;更新翻譯要有個 queue，才可以多人合作時不炸掉 autobuild server。&lt;/li&gt;
&lt;li&gt;每日更新全部的文件，並且把更新加到 CPython-tw 的 git repo 中。更新的過程一樣要有記錄。&lt;/li&gt;
&lt;li&gt;上述的所有功能都能在本機輕鬆地設定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;實作&lt;/h3&gt;
&lt;p&gt;目標就是完成上述的需求。pydoc 基本上就是個 static site，交給 nginx 設好路徑 host static files 就可以。Pydoc Sphinx 用 &lt;a href="http://jinja.pocoo.org/docs/dev/"&gt;Jinja2&lt;/a&gt; 作 HTML template，所以只要多加一些變數就能控制頁面的輸出，在 autobuild server 上時就可以加上額外的連結。而 Autobuild server 本身是個 task queue，其實功能很簡單，但為了維護方便，並考慮到 local、production 環境都要能動的話，選擇 &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; 為基礎。真的給 Django 管理的就顯示 task queue、task result、接受 rebuild doc request 這幾個 view。&lt;/p&gt;
&lt;h4 id="sphinx_1"&gt;Sphinx 文件&lt;/h4&gt;
&lt;p&gt;在 Sphinx 文件部份不想搞太複雜，就在每一頁加上一個自己的專屬連結，打這個網址就會加入一個更新該頁面的 task 到 autobuild server&lt;sup id="fnref:build-link"&gt;&lt;a class="footnote-ref" href="#fn:build-link"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;在 autobuild 時加入專屬連結只要修改 Sphinx doc template 即可。Sphinx 在 build doc 時可以透過 &lt;a href="http://www.sphinx-doc.org/en/stable/man/sphinx-build.html#options"&gt;&lt;code&gt;-A &amp;lt;name=value&amp;gt;&lt;/code&gt;&lt;/a&gt; 增加 Jinja2 template 的變數，就可控制 template render 行為：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;{# &amp;lt;cpython-src&amp;gt;/Doc/tools/templates/layout.html #}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;autobuildi18n&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/_build/update/?source_path=&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;pagename&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Update Translation&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sphinx-build -A autobuildi18n=1&lt;/code&gt; 時就會包含這個 Jinja2 block，多這個 Update Translation 連結。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sphinx-doc.org/en/stable/templating.html#pagename"&gt;&lt;code&gt;{{ pagename }}&lt;/code&gt;&lt;/a&gt; 是每頁文件的 rst 路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="autobuild-django-server"&gt;Autobuild Django server&lt;/h4&gt;
&lt;p&gt;Django server 目標就是接受 task request 和顯示 task result。一個標準的 task queue 就有這些功能。&lt;/p&gt;
&lt;p&gt;Django 上的 task queue 選擇很多，從 &lt;a href="https://www.djangopackages.com/"&gt;Django Packages&lt;/a&gt; 上的 &lt;a href="https://www.djangopackages.com/grids/g/workers-queues-tasks/"&gt;Workers, Queues, and Tasks&lt;/a&gt; 相關的套件可以看到有幾個有在更新而且 up 數多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://celery.github.io/django-celery/"&gt;django-celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://huey.readthedocs.org/en/latest/"&gt;huey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ui/django-rq"&gt;django-RQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://policystat.github.io/jobtastic/"&gt;jobtastic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扣掉不支援 Python 3 的套件&lt;sup id="fnref:python3"&gt;&lt;a class="footnote-ref" href="#fn:python3"&gt;4&lt;/a&gt;&lt;/sup&gt;後，就剩 django-celery、django-RQ、django-Q 可以選。這裡面最紅也最老牌的是 django-celery ，它與 &lt;a href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; 整合，功能完整且穩定，我用過也覺得十分不錯，缺點是功能太多有點複雜，加上不同 message queue 時會有很多設定要調整，需要一段時間上手。一般 Celery 常見的搭配使用 &lt;a href="https://www.rabbitmq.com/"&gt;Rabbit-MQ&lt;/a&gt; 和 &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;，的確在 task 很多時有必要，但我們這個 build doc 一天可能才十幾次，在不隔離 build doc 環境的情況同時間的 worker 只能有一個，不會有效能上的問題。因此我傾向只要使用與 Django 同一個 database 就好，不要再有額外非 Python 的 dependency，讓 local 開發簡單一點。&lt;/p&gt;
&lt;p&gt;最後選擇 &lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;。雖然很新但作者維護得很勤，worker 可以只用 Python 內建的 multiprocessing 完成。功能簡單卻完整，包含 monitor，跟 django-admin 整合，還可以排程。所以要啟動 django-Q 的 cluster，只要多一個 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python manage.py qcluster
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可，十分方便。&lt;/p&gt;
&lt;p&gt;怎麼使用 django-Q 就不在這篇 blog 討論範圍內了。我想我應該會投稿 PyCon TW 或 Taipei.py，到時候再整理成另一篇。Django-Q 的說明文件寫得很清楚，讀一讀應該就會了。&lt;/p&gt;
&lt;h2 id="autobuild-server"&gt;Autobuild server 部署&lt;/h2&gt;
&lt;p&gt;（這篇文的重點其實是部署，誰曉得背景介紹可以這麼長）&lt;/p&gt;
&lt;p&gt;部署 (deploy) 方法百百種，有好有壞。但至少要會一種嘛，所以這邊就用其中一種：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也算很流行的組合。更完整地來說，整個處理 request 的流程經過：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;web client &amp;lt;-&amp;gt; nginx web server &amp;lt;-&amp;gt; socket &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本的設定與教學來自 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/index.html"&gt;uWSGI&lt;/a&gt; 官網的 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文，搭配 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;uWGSI and Systemd&lt;/em&gt;&lt;/a&gt; 與 &lt;a href="https://www.freedesktop.org/wiki/Software/systemd/"&gt;systemd&lt;/a&gt; 整合。&lt;/p&gt;
&lt;p&gt;這也是目前 Pydoc production 的設定，記錄一下方便未來的維護。&lt;/p&gt;
&lt;h3 id="_3"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;作業系統用 Debian Jessie，架設於 Amazon EC2 上，使用 t2.nano&lt;sup id="fnref:ec2-nano"&gt;&lt;a class="footnote-ref" href="#fn:ec2-nano"&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;Python web deploy 都會把套件裝在虛擬環境中，避免不同專案間互衝或與系統衝突。在 Debian 上可以用 &lt;code&gt;apt buid-dep python3-&amp;lt;pkg&amp;gt;&lt;/code&gt; 把 Python &lt;pkg&gt; 套件所需的 header 或 library 安裝好，十分簡單。&lt;/p&gt;
&lt;h4 id="python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/h4&gt;
&lt;p&gt;我的 code 裡用到了 &lt;a href="https://docs.python.org/3/library/subprocess.html#subprocess.run"&gt;&lt;code&gt;subprocess.run&lt;/code&gt;&lt;/a&gt;，這是 Python 3.5+ 才有的 API。但 Jessie 只有 Python 3.4，但我覺得很好用一點都不想改寫成相容舊版的 code。&lt;/p&gt;
&lt;p&gt;因此需要安裝 Debian testing channel 上最新的 Python 3.5。這樣其實有安全上的疑慮，因為只有 stable channel 才有 security support，但自己編譯的問題更大，所以像 &lt;a href="https://github.com/yyuu/pyenv"&gt;pyenv&lt;/a&gt; 這種多 Python 版本的工具不在考慮內。&lt;/p&gt;
&lt;p&gt;於是用 &lt;a href="https://wiki.debian.org/AptPreferences"&gt;Apt-Pinning&lt;/a&gt; 只讓 Python 3.5 相關的套件安裝 testing 的版本。首先把 testing channel 加到 &lt;code&gt;/etc/apt/source.list&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;deb&lt;/span&gt; &lt;span class="s"&gt;http://cloudfront.debian.net/debian&lt;/span&gt; &lt;span class="kp"&gt;testing&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt;
&lt;span class="k"&gt;deb-src&lt;/span&gt; &lt;span class="s"&gt;http://cloudfront.debian.net/debian&lt;/span&gt; &lt;span class="kp"&gt;testing&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt;
&lt;span class="k"&gt;deb&lt;/span&gt; &lt;span class="s"&gt;http://security.debian.org/&lt;/span&gt; &lt;span class="kp"&gt;testing/updates&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt;
&lt;span class="k"&gt;deb-src&lt;/span&gt; &lt;span class="s"&gt;http://security.debian.org/&lt;/span&gt; &lt;span class="kp"&gt;testing/updates&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然後修改 &lt;code&gt;/etc/apt/preferences&lt;/code&gt; 確定我們不會不小心裝到 testing 相關的套件，並把 Python 3.5 相關的套件設定權限 &amp;gt;= 990 讓它們能被自動安裝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Specify * rules first so later package-specfic rules can override them
Package: *
Pin: release a=testing
Pin-Priority: -10

Package: python3.5* libpython3.5*
Pin: release a=testing
Pin-Priority: 990
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以用 &lt;code&gt;sudo apt-cache policy &amp;lt;pkg-name&amp;gt;&lt;/code&gt; 檢查目前的規則會裝到哪個版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo apt-get update 
$ sudo apt-get install python3.5 python3.5-venv python3.5-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣只有 Python 3.5 相關的套件才會裝到 testing。&lt;/p&gt;
&lt;h4 id="postgresql"&gt;資料庫 PostgreSQL&lt;/h4&gt;
&lt;p&gt;資料庫用 PostgreSQL 9.4。參照之前 blog&lt;a href="https://blog.liang2.tw/posts/2016/01/postgresql-install/"&gt;《安裝 PostgreSQL 9 於 Debian Jessie / OSX》&lt;/a&gt;一文設定。&lt;/p&gt;
&lt;h4 id="swap"&gt;Swap&lt;/h4&gt;
&lt;p&gt;其實是上線不久才注意到 EC2 預設沒有 swap 空間。我很窮所以 production server 的 RAM 只有 512 MB，觀察一下有時候 build doc RAM 就全滿了，所以還是加個 swap 安心一點。&lt;/p&gt;
&lt;p&gt;因為 Amazon EBS SSD I/O 數不會另外收錢（應該吧？），就建 swap file 在主硬碟裡。&lt;/p&gt;
&lt;p&gt;Swap 設定的教學很多，這邊就參考 &lt;a href="https://wiki.archlinux.org/index.php/swap"&gt;Arch Wiki&lt;/a&gt; 上的做法，我選擇放在 &lt;code&gt;/var/swap.1&lt;/code&gt;。大小設定為 RAM 的 2 倍，即 1GB。&lt;/p&gt;
&lt;p&gt;首先把這個檔案建出來，權限改為 600。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /bin/dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/swap.1 &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;
&lt;span class="c1"&gt;# or faster with fallocate&lt;/span&gt;
sudo fallocate -l 1G /var/swap.1
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo chmod &lt;span class="m"&gt;600&lt;/span&gt; /var/swap.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再來把這個檔案改成 swap 格式並啟用它，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /sbin/mkswap /var/swap.1
sudo /sbin/swapon /var/swap.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改 fstab 讓每次開機都有這個 swap 設定，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# /etc/fstab
/var/swap.1 none swap defaults 0 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用 &lt;code&gt;free -h&lt;/code&gt;、&lt;code&gt;cat /proc/meminfo&lt;/code&gt; 檢查此時應該有個 1GB swap 了。&lt;/p&gt;
&lt;h4 id="git-repo-ssh-config"&gt;Git repo ssh config&lt;/h4&gt;
&lt;p&gt;再來是 code 的同步與更新。autobuild server 只要更新 source code，但 cpython-tw source 需要定時 commit 新的翻譯，因此 deploy server 會有修改 git repo 的權限。&lt;/p&gt;
&lt;p&gt;不應該使用自己的 SSH key，deploy server 上應該有專屬的 deploy key，其中 cpython-tw 的 deploy key 有寫入權限（即可以 commit）。&lt;/p&gt;
&lt;p&gt;查了一下，要讓不同 git repo 使用不同的 SSH key 也不複雜。以這邊的例子，先修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 加入兩個新的 host，使用不同的 SSH key：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Host github-pydoc_autobuild
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.pydoc_autobuild

Host github-cpython_tw
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.cpython_tw
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;建立對應的 SSH keypair，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa.pydoc_autobuild
ssh-keygen -t rsa -f ~/.ssh/id_rsa.cpython_tw
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把兩個 repo 的 URL host 換掉，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git remote set-url origin git@github-pydoc_autobuild:python-doc-tw/pydoc_autobuild.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣兩個 repo 會透過給定的 ssh key 連線。GitHub 會顯示每個 key 最近使用的時間，檢查時間就能確認設定正確與否（而且改 host 沒設定對應該直接連不上）。&lt;/p&gt;
&lt;h4 id="tmpfilesd"&gt;tmpfiles.d&lt;/h4&gt;
&lt;p&gt;之後 nginx 和 uwsgi 溝通用的 socket 打算放在 &lt;code&gt;/run/django/xxxx.sock&lt;/code&gt; &lt;sup id="fnref:/run"&gt;&lt;a class="footnote-ref" href="#fn:/run"&gt;6&lt;/a&gt;&lt;/sup&gt;。因為只需要非 root 的權限，修改 &lt;a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles.d&lt;/a&gt; 的設定，讓這個資料夾能在開機時自動建立。增加設定檔 &lt;code&gt;/etc/tmpfiles.d/pydoc_autobuild.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;d /run/django 0755 pydoc www-data
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/h3&gt;
&lt;p&gt;在本地開發都用 &lt;code&gt;python manage.py runserver&lt;/code&gt; 啟動 Django。但上線時內建的 runserver 就無法同時間服務太多人。因此需要像 nginx、uWSGI 等工具來協助。&lt;/p&gt;
&lt;p&gt;參照 uWSGI &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文以及 TP 寫的 《為程式人寫的 Django Tutorial》系列文中 &lt;a href="https://github.com/uranusjr/django-tutorial-for-programmers/blob/master/25-deploy-to-ubuntu-server.md"&gt;&lt;em&gt;Day 27 - Deploy to Ubuntu server&lt;/em&gt;&lt;/a&gt; 關於部署的文章。&lt;/p&gt;
&lt;p&gt;Autobuild server 有特別為 production 寫一份設定檔，切換時只要設定成 &lt;code&gt;settings.production&lt;/code&gt; 即可。在 Django 設定部份，建議把所有路徑都設成絕對路徑（包含執行檔）。不然後續在設定 systemd 要調整很多環境變數，systemd 也不會帶入使用者的 PATH 變數，不用絕對路徑其實蠻麻煩的也容易錯。&lt;/p&gt;
&lt;h4 id="nginx"&gt;nginx 設定&lt;/h4&gt;
&lt;p&gt;nginx 會接受 incoming HTTP request，需要跟 Django server 聯絡時，就會會連到 uWSGI 開的 UNIX socket。&lt;/p&gt;
&lt;p&gt;我們先假設 uWSGI 這段沒問題，首先設定 nginx 本身。由於 static files 在 nginx 就直接導到對應的檔案，不會經過 uWSGI ，所以設定好 nginx 之後 pydoc 文件本身就上線了。用這個來測試設定的正確性。&lt;/p&gt;
&lt;p&gt;對本網站而言，/static 導到 Django staticfiles；/3/、/3.5/ 導到 pydoc build HTML 的路徑；其餘路徑再交給 Django 處理。其中，/3.5/* 的連結將重新導向到 /3/* 上。&lt;/p&gt;
&lt;p&gt;整理上述的需求，寫個 nginx 設定檔在 &lt;code&gt;/etc/nginx/sites-available/pydoc_autobuild.conf&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Upstream Django setting; the socket nginx connects to&lt;/span&gt;
&lt;span class="k"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;django&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:///run/django/pydoc_autobuild.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;      &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;default&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;docs.python.org.tw&lt;/span&gt;
                &lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="s"&gt;.69.170.26&lt;/span&gt;
                &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;charset&lt;/span&gt;     &lt;span class="s"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="s"&gt;10M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# max upload size&lt;/span&gt;
    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/static&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/code/pydoc_autobuild/assets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/3&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/path/to/code/cpython-tw/Doc/build/html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;/3\.5/(.*)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;302&lt;/span&gt; &lt;span class="s"&gt;/3/&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Finally, send all non-media requests to the Django server.&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt;  &lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;include&lt;/span&gt;     &lt;span class="s"&gt;/etc/nginx/uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再把檔案 soft link 到 &lt;code&gt;/etc/nginx/sites-enabled/&lt;/code&gt;，更新 nginx 設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/nginx/sites-available/
sudo ln -s pydoc_autobuild.conf ../sites-enabled/
sudo systemctl reload nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;確定 pydoc 上線就可以專心處理 uWSGI 了。&lt;/p&gt;
&lt;h4 id="uwsgi"&gt;uWSGI 設定&lt;/h4&gt;
&lt;p&gt;uWSGI 在 VENV 外也要裝，我覺得還是用 pip 比較簡單，雖然這樣就要自己注意 uWSGI 的版本更新了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo python3.5 -m pip install uwsgi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把 uWSGI 設定存成 &lt;code&gt;pydoc_autobuild_uwsgi.ini&lt;/code&gt; 並且在測試時，都使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo uwsgi --ini pydoc_autobuild_uwsgi.ini
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模擬實際上的執行方式，這樣之後改用 systemd 執行才不會又丟一堆權限的問題。設定檔的內容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;chdir&lt;/span&gt;        &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/code/pydoc_autobuild&lt;/span&gt;
&lt;span class="c1"&gt;# Django&amp;#39;s wsgi file&lt;/span&gt;
&lt;span class="na"&gt;module&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;pydoc_autobuild.wsgi:application&lt;/span&gt;
&lt;span class="na"&gt;env&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production&lt;/span&gt;
&lt;span class="c1"&gt;# the virtualenv (full path)&lt;/span&gt;
&lt;span class="na"&gt;home&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/path/to/VENV&lt;/span&gt;

&lt;span class="c1"&gt;# process-related settings&lt;/span&gt;
&lt;span class="c1"&gt;# master&lt;/span&gt;
&lt;span class="na"&gt;master&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;span class="c1"&gt;# maximum number of worker processes&lt;/span&gt;
&lt;span class="na"&gt;processes&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;4&lt;/span&gt;
&lt;span class="c1"&gt;# the socket (use the full path to be safe&lt;/span&gt;
&lt;span class="na"&gt;socket&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/run/django/pydoc_autobuild.sock&lt;/span&gt;
&lt;span class="c1"&gt;# ... with appropriate permissions - may be needed&lt;/span&gt;
&lt;span class="na"&gt;chmod-socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;664&lt;/span&gt;
&lt;span class="na"&gt;uid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;pydoc&lt;/span&gt;
&lt;span class="na"&gt;gid&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;www-data&lt;/span&gt;
&lt;span class="c1"&gt;# clear environment on exit&lt;/span&gt;
&lt;span class="na"&gt;vacuum&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;權限上的設定可能要花點時間處理一下，nginx 使用 www-data/www-data 的身份執行，socket 要確定 nginx 能讀寫，但我的 code 放在 pydoc 使用者路徑下，用 www-data 可能會有權限的問題。建議把 uid、gid 都設定好。&lt;/p&gt;
&lt;p&gt;過程中，搭配 nginx 的錯誤訊息比較好 debug：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo less +F /var/log/nginx/error.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;成功後，再用 uWSGI 的 Emperor mode，把設定檔丟到一個路徑底下（該路徑稱為 vassals）。uWSGI 在 Emperor mode 時會自動把 vassals 路徑內所有設定檔都讀進來並執行。&lt;/p&gt;
&lt;p&gt;這裡 vassals 路徑使用 &lt;code&gt;/etc/uwsgi/vassals/&lt;/code&gt;。因為有設 uid、gid，跑的時候就不用再設了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo uwsgi --emperor /etc/uwsgi/vassals
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣應該 Django 相關的 view 都沒問題了。接下來，要把啟動 uWSGI 的步驟交給系統來管理。&lt;/p&gt;
&lt;h3 id="systemd-services"&gt;Systemd services&lt;/h3&gt;
&lt;p&gt;Autobuild server 包含兩個部份：Django Server 與 Django-Q cluster。所以寫成 systemd service 時會有兩個服務。&lt;/p&gt;
&lt;p&gt;Debian system service 放在 &lt;code&gt;/etc/systemd/system/&lt;/code&gt; 底下，因此建立 &lt;code&gt;uwsgi.service&lt;/code&gt; 和 &lt;code&gt;qcluster.service&lt;/code&gt; 分別管理 uWSGI Emperor mode 和 Django-Q cluster。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uwsgi.service&lt;/code&gt; 參考 uWSGI 官網 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;Django and Systemd&lt;/em&gt;&lt;/a&gt; 一文的設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;uWSGI Emperor&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog.target&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals&lt;/span&gt;
&lt;span class="na"&gt;RuntimeDirectory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;uwsgi&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;KillSignal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;SIGQUIT&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;notify&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;
&lt;span class="na"&gt;NotifyAccess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;all&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;qcluster.service&lt;/code&gt; 算是自己硬寫模擬 &lt;code&gt;python manage.py qcluster&lt;/code&gt; 行為。因此環境變數都要設定好（當然用絕對路徑就沒問題了，我只是覺得這樣 build log 內的執行檔路徑都很長會很醜 xd）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;Django-Q Cluster for site pydoc_autobuild&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog.target&lt;/span&gt;
&lt;span class="na"&gt;Wants&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;uwsgi.service&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;pydoc&lt;/span&gt;
&lt;span class="na"&gt;Group&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;www-data&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;VIRTUAL_ENV=/path/to/VENV&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PATH=/path/to/VENV/bin:$PATH&lt;/span&gt;
&lt;span class="na"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production&lt;/span&gt;
&lt;span class="na"&gt;WorkingDirectory&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/path/to/code/pydoc_autobuild&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/path/to/VENV/bin/python manage.py qcluster&lt;/span&gt;
&lt;span class="na"&gt;Restart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;always&lt;/span&gt;
&lt;span class="na"&gt;KillSignal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;SIGQUIT&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;simple&lt;/span&gt;
&lt;span class="na"&gt;NotifyAccess&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;none&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這樣的設定檔應該不是 systemd 的慣例，我還在想是不是應該要改寫到 user service 去（但我不會）。&lt;/p&gt;
&lt;p&gt;加入到 systemd 之後管理就很簡單，啟動這兩個 service：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo systemctl enable uwsgi
sudo systemctl enable qcluster
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看他們的狀態：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo systemctl status uwsgi
sudo systemctl status qcluster
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看它們的 log 也變得很簡單，因為有把它們的 stderr 抓起來。systemd 好處是 rotation 等等都會幫你注意，看 log 的功能也很多。&lt;/p&gt;
&lt;p&gt;例如要查最近一小時 uWSGI 的連線記錄，並在有新連線時持續更新 log：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo journalctl -xef -u uwsgi --since &amp;#39;1 hour ago&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_4"&gt;總結&lt;/h2&gt;
&lt;p&gt;介紹了 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件翻譯計畫&lt;/a&gt;，線上文件autobuild server 基於 Django 與 Django-Q 的架構，以及在 Debian 上結合 nginx、uWSGI、systemd 的部署設定。&lt;/p&gt;
&lt;p&gt;查資料時覺得文章還不多，只有幾篇像 &lt;a href="https://luxagraf.net/src/how-set-django-uwsgi-systemd-debian-8"&gt;&lt;em&gt;How to Set Up Django with Nginx, uWSGI &amp;amp; systemd on Debian/Ubuntu&lt;/em&gt;&lt;/a&gt; 的文章，剩下要自己組裝還是要花一點時間。同時也把部署 pydoc server 的設定都記在這，將來要重建也比較簡單。&lt;/p&gt;
&lt;p&gt;關於說明文件翻譯，應該會再花篇文章好好寫整個計畫本身。&lt;/p&gt;
&lt;p&gt;（是說如果有人能從頭看到尾的話，給個回饋吧 &amp;gt; &amp;lt;）&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:zh-Hant"&gt;
&lt;p&gt;八卦是，臺灣繁體中文的 language code (or locale identifier) 究竟是 zh_TW、zh-Hant、zh-Hant-TW、zh-Hant_TW、zh_Hant 還是 zh_Hant_TW？這問題本身就可以寫一篇了。&lt;br&gt;&lt;br&gt;查國際規範 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的話，只有 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant"&gt;zh-Hant&lt;/a&gt; 和 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant-TW"&gt;zh-Hant-TW&lt;/a&gt;，更多關於標準的說明與定義可以參考 &lt;a href="https://www.w3.org/International/articles/bcp47/"&gt;&lt;em&gt;Understanding the New Language Tags&lt;/em&gt;, W3C&lt;/a&gt; 一文。&lt;br&gt;&lt;br&gt;不過現狀是很奇妙的。參考 OSX 定義 &lt;a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html"&gt;&lt;em&gt;Language and Locale IDs&lt;/em&gt;&lt;/a&gt; 的話應該是 zh_TW、zh-Hant 或 zh-Hant_TW。而在 Debain 中，所有支援的 locale 寫在 &lt;code&gt;/usr/share/i18n/SUPPORTED&lt;/code&gt;，裡面只有 zh_TW，不過 Debian 只用 &lt;code&gt;language[_country][.charset]&lt;/code&gt; 所以不會有定義中為 script 的 Hant，雖然在 locale 中使用底線與 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的定義不同。Sphinx 透過 &lt;a href="http://babel.pocoo.org/"&gt;Babel&lt;/a&gt; 處理 locale，但它不允許 locale 中有 &lt;code&gt;-&lt;/code&gt;，因此只能考慮 zh_Hant 或 zh_Hant_TW。更有趣的是，locale 應該是 case-insensitive 所以大小寫是不重要的 XD&amp;#160;&lt;a class="footnote-backref" href="#fnref:zh-Hant" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:pydoc-url"&gt;
&lt;p&gt;其實在 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt; 上面 &lt;a href="https://docs.python.org/3/"&gt;/3/&lt;/a&gt; 和 &lt;a href="https://docs.python.org/3.5/"&gt;/3.5/&lt;/a&gt; 是不同份文件，即使是同個版本號它們更新的時間不相同。蠻意外會是這樣的情況。不過我們不用搞這麼複雜，只要轉址就好。&amp;#160;&lt;a class="footnote-backref" href="#fnref:pydoc-url" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:build-link"&gt;
&lt;p&gt;開發時一直都是用 GET，即如文中所說，有個專屬的 link。但發現會有 robot / crawler 打這些路徑，因此最後改成 POST，把 &lt;code&gt;{{ pagename }}&lt;/code&gt; 用 data-* 即 &lt;code&gt;&amp;lt;a href="#" data-pagename="{{ pagename }}"&amp;gt;...&amp;lt;/a&amp;gt;&lt;/code&gt; 的方式存起來，在用 jQuery 綁定 click listener。&amp;#160;&lt;a class="footnote-backref" href="#fnref:build-link" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:python3"&gt;
&lt;p&gt;看 &lt;a href="https://github.com/coleifer/huey"&gt;huey&lt;/a&gt; 和 &lt;a href="https://github.com/PolicyStat/jobtastic"&gt;jobtastic&lt;/a&gt; master branch 上有 py3k 的 commit 但感覺是最近的事，有待觀察。&amp;#160;&lt;a class="footnote-backref" href="#fnref:python3" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:ec2-nano"&gt;
&lt;p&gt;吐嘈一下，t2.nano vCPU 真的時快時慢，有時 build doc 幾分鐘就搞定了，有時要幾十分鐘，有一天超慢，然後又被 web crawler 抓到，讓 task queue timeout 陷入了 timeout、restart、timeout 的無限地獄……&amp;#160;&lt;a class="footnote-backref" href="#fnref:ec2-nano" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:/run"&gt;
&lt;p&gt;/var/run = /run，這個路徑是個 tmpfs 所以每次重開機就會清空，目錄要記得重建。&amp;#160;&lt;a class="footnote-backref" href="#fnref:/run" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="zh"></category><category term="pydoctw"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category></entry><entry><title>安裝 PostgreSQL 9 於 Debian Jessie / OSX</title><link href="https://blog.liang2.tw/posts/2016/01/postgresql-install/" rel="alternate"></link><published>2016-01-25T17:00:00-06:00</published><updated>2016-01-25T17:00:00-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-25:/posts/2016/01/postgresql-install/</id><summary type="html">&lt;p&gt;平常用最多的是 &lt;a href="https://www.sqlite.org/"&gt;SQLite&lt;/a&gt;，但 &lt;a href="http://www.postgresql.org/"&gt;PostgreSQL&lt;/a&gt; 有很多好用的功能，每次要用想不起來怎麼裝。總之把相關設定的筆記存在這。&lt;/p&gt;
&lt;p&gt;用 &lt;a href="https://www.debian.org/releases/stable/"&gt;Debian Jessie&lt;/a&gt; (Debian 8.3) 與 OSX &lt;a href="http://brew.sh/"&gt;Homebrew&lt;/a&gt; 舉例。不過 OSX 大概也不會沒事把 PostgreSQL 開著，主要是著重在 Debian …&lt;/p&gt;</summary><content type="html">&lt;p&gt;平常用最多的是 &lt;a href="https://www.sqlite.org/"&gt;SQLite&lt;/a&gt;，但 &lt;a href="http://www.postgresql.org/"&gt;PostgreSQL&lt;/a&gt; 有很多好用的功能，每次要用想不起來怎麼裝。總之把相關設定的筆記存在這。&lt;/p&gt;
&lt;p&gt;用 &lt;a href="https://www.debian.org/releases/stable/"&gt;Debian Jessie&lt;/a&gt; (Debian 8.3) 與 OSX &lt;a href="http://brew.sh/"&gt;Homebrew&lt;/a&gt; 舉例。不過 OSX 大概也不會沒事把 PostgreSQL 開著，主要是著重在 Debian 的環境設定上。目前 PostgreSQL 出到 9.5 但 Debian stable 是 9.4。基本設定應該完全沒差別。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;安裝 PostgreSQL&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#osx"&gt;安裝在 OSX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debian-jessie"&gt;安裝在 Debian Jessie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#database"&gt;初始個人的 Database&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#postgresql_1"&gt;建立同使用者名稱的 PostgreSQL 帳號&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#database_1"&gt;建立與帳號同名稱的 database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#psql"&gt;用使用者帳號連接 psql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#psql_1"&gt;psql 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#database_2"&gt;刪除使用者、Database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;進階主題&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#psql_2"&gt;透過 psql 創建使用者帳號、資料庫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql-logging"&gt;PostgreSQL Logging&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#logging-postgresql"&gt;Logging 讓 PostgreSQL 自己管&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#logging-systemd"&gt;Logging 透過 Systemd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#reference"&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="postgresql"&gt;安裝 PostgreSQL&lt;/h2&gt;
&lt;h3 id="osx"&gt;安裝在 OSX&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;brew install postgresql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要用的時候手動把 PostgreSQL server 打開，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;postgres -D /usr/local/var/postgres&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PostgreSQL 的設定參考 Debian 的版本。&lt;/p&gt;
&lt;h3 id="debian-jessie"&gt;安裝在 Debian Jessie&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo apt-get install postgresql-9.4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;現在系統服務都由 &lt;a href="http://freedesktop.org/wiki/Software/systemd/"&gt;Systemd&lt;/a&gt; 管理了，檢查 PostgreSQL 有沒有跑起來透過 &lt;code&gt;systemctl&lt;/code&gt; 這指令就可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl status postgresql.service
&lt;span class="go"&gt;● postgresql.service - PostgreSQL RDBMS&lt;/span&gt;
&lt;span class="go"&gt;   Loaded: loaded (/lib/systemd/system/postgresql.service; enabled)&lt;/span&gt;
&lt;span class="go"&gt;   Active: inactive (dead) since Mon 2016-01-25 17:26:08 CST; 4s ago&lt;/span&gt;
&lt;span class="go"&gt;  Process: 913 ExecStart=/bin/true (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;span class="go"&gt; Main PID: 913 (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不過這 service 看不太到什麼運行的資訊，其實是個 dummy service，它會 trigger 可能很多個 PostgreSQL database cluster 什麼的。預設只有一個 &lt;code&gt;main&lt;/code&gt; 的 cluster。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl status postgresql@9.4-main.service
&lt;span class="go"&gt;● postgresql@9.4-main.service - PostgreSQL Cluster 9.4-main&lt;/span&gt;
&lt;span class="go"&gt;   Loaded: loaded (/lib/systemd/system/postgresql@.service; disabled)&lt;/span&gt;
&lt;span class="go"&gt;   Active: active (running) since Mon 2016-01-25 17:26:30 CST; 4min 7s ago&lt;/span&gt;
&lt;span class="go"&gt;  Process: 9641 ExecStop=/usr/bin/pg_ctlcluster -m fast %i stop (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;span class="go"&gt;  Process: 9717 ExecStart=postgresql@%i %i start (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;span class="go"&gt; Main PID: 9723 (postgres)&lt;/span&gt;
&lt;span class="go"&gt;   CGroup: /system.slice/system-postgresql.slice/postgresql@9.4-main.service&lt;/span&gt;
&lt;span class="go"&gt;           ├─9723 /usr/lib/postgresql/9.4/bin/postgres -D /var/lib/postgresql/9.4/main -c config_file=/etc/postgr...&lt;/span&gt;
&lt;span class="go"&gt;           ├─9725 postgres: checkpointer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─9726 postgres: writer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─9727 postgres: wal writer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─9728 postgres: autovacuum launcher process&lt;/span&gt;
&lt;span class="go"&gt;           └─9729 postgres: stats collector process&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="database"&gt;初始個人的 Database&lt;/h2&gt;
&lt;p&gt;在 OSX 上用 homebrew 安裝 PostgreSQL 的使用者會有 superuser 的權限，反正是本地開發也沒差，建 database 等設定都比較簡單。&lt;/p&gt;
&lt;p&gt;在 Debian 上的話，有這 superuser 權限的使用者為 &lt;code&gt;postgres&lt;/code&gt;。所以預設使用者（這邊以 &lt;code&gt;vm&lt;/code&gt; 為例）會無法連線。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; psql
&lt;span class="go"&gt;psql: FATAL:  role &amp;quot;vm&amp;quot; does not exist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;切到 root 再切到 postgres 身份就能用 &lt;code&gt;psql&lt;/code&gt; （PostgreSQL 的 REPL shell）連到 database。用 &lt;code&gt;\q&lt;/code&gt; 就可以退出 psql。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -u postgres psql
&lt;span class="go"&gt;[sudo] password for vm:&lt;/span&gt;
&lt;span class="go"&gt;psql (9.4.5)&lt;/span&gt;
&lt;span class="go"&gt;Type &amp;quot;help&amp;quot; for help.&lt;/span&gt;

&lt;span class="go"&gt;postgres=# \q&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但用 postgres 這 superuser 去連資料庫不是很安全，一開始養成好習慣應該用個人帳號。所以接下來要完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立同使用者名稱的 PostgreSQL 帳號&lt;/li&gt;
&lt;li&gt;建立與帳號同名稱的 database&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="postgresql_1"&gt;建立同使用者名稱的 PostgreSQL 帳號&lt;/h3&gt;
&lt;p&gt;在 Debian 上可以用 &lt;code&gt;$USER&lt;/code&gt; 來抓到現在登入者的帳號，即使用 sudo 切換身份這環境變數的值不會變。（讀 &lt;a href="https://help.ubuntu.com/community/PostgreSQL"&gt;Ubuntu wiki&lt;/a&gt; 看到的技巧）&lt;/p&gt;
&lt;p&gt;擔心的話就直接在有 &lt;code&gt;$USER&lt;/code&gt; 的地方打出帳號即可。先確認一下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;vm@vm-debian:~$ echo $&lt;/span&gt;USER
&lt;span class="go"&gt;vm&lt;/span&gt;
&lt;span class="gp"&gt;vm@vm-debian:~$&lt;/span&gt; sudo -u postgres &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$USER&lt;/span&gt;
&lt;span class="go"&gt;vm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;建立使用者是透過 &lt;code&gt;createuser&lt;/code&gt; 這指令。這是使用者帳號就不給太多權限。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -u postgres createuser --interactive &lt;span class="nv"&gt;$USER&lt;/span&gt;
&lt;span class="go"&gt;Shall the new role be a superuser? (y/n) n&lt;/span&gt;
&lt;span class="go"&gt;Shall the new role be allowed to create databases? (y/n) n&lt;/span&gt;
&lt;span class="go"&gt;Shall the new role be allowed to create more new roles? (y/n) n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這時候透過 &lt;code&gt;psql&lt;/code&gt; 看就會多一個使用者。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- Run with command `sudo -u postgres psql`&lt;/span&gt;
&lt;span class="gp"&gt;postgres=#&lt;/span&gt; &lt;span class="kp"&gt;\du&lt;/span&gt;
                             &lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="n"&gt;roles&lt;/span&gt;
 &lt;span class="k"&gt;Role&lt;/span&gt; &lt;span class="k"&gt;name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;                   &lt;span class="n"&gt;Attributes&lt;/span&gt;                   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Member&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt;
&lt;span class="c1"&gt;-----------+------------------------------------------------+-----------&lt;/span&gt;
 &lt;span class="n"&gt;postgres&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Superuser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;Create&lt;/span&gt; &lt;span class="k"&gt;role&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;Create&lt;/span&gt; &lt;span class="n"&gt;DB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Replication&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
 &lt;span class="n"&gt;vm&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt;                                                &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="database_1"&gt;建立與帳號同名稱的 database&lt;/h3&gt;
&lt;p&gt;透過 &lt;code&gt;createdb&lt;/code&gt; 這指令。把與帳號同名 database 的 owner 設定成該帳號。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -u postgres createdb --owner&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$USER&lt;/span&gt; &lt;span class="nv"&gt;$USER&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要多建別的 database 給這帳號也沒問題，例如名為 &lt;code&gt;vm_database&lt;/code&gt; 的 database，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo -u postgres createdb --owner&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$USER&lt;/span&gt; vm_database
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="psql"&gt;用使用者帳號連接 psql&lt;/h3&gt;
&lt;p&gt;這時候打 &lt;code&gt;psql&lt;/code&gt; 就沒問題了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; psql
&lt;span class="go"&gt;psql (9.4.5)&lt;/span&gt;
&lt;span class="go"&gt;Type &amp;quot;help&amp;quot; for help.&lt;/span&gt;

&lt;span class="go"&gt;vm=&amp;gt; \conninfo&lt;/span&gt;
&lt;span class="go"&gt;You are connected to database &amp;quot;vm&amp;quot; as user &amp;quot;vm&amp;quot; via socket in &amp;quot;/var/run/postgresql&amp;quot; at port &amp;quot;5432&amp;quot;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Prompt 從 &lt;code&gt;#=&lt;/code&gt; 變成 &lt;code&gt;=&amp;gt;&lt;/code&gt; 表示現在連線的使用者不是 superuser。透過 psql 的指令 &lt;code&gt;\l&lt;/code&gt; 或 &lt;code&gt;\l+&lt;/code&gt; 可以看現在所有的 database：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;vm=&amp;gt;&lt;/span&gt; &lt;span class="kp"&gt;\l&lt;/span&gt;
&lt;span class="go"&gt;                                   List of databases&lt;/span&gt;
&lt;span class="go"&gt;    Name     |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges&lt;/span&gt;
&lt;span class="go"&gt;-------------+----------+----------+-------------+-------------+-----------------------&lt;/span&gt;
&lt;span class="go"&gt; postgres    | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |&lt;/span&gt;
&lt;span class="go"&gt; template0   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +&lt;/span&gt;
&lt;span class="go"&gt;             |          |          |             |             | postgres=CTc/postgres&lt;/span&gt;
&lt;span class="go"&gt; template1   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +&lt;/span&gt;
&lt;span class="go"&gt;             |          |          |             |             | postgres=CTc/postgres&lt;/span&gt;
&lt;span class="go"&gt; vm          | vm       | UTF8     | en_US.UTF-8 | en_US.UTF-8 |&lt;/span&gt;
&lt;span class="go"&gt; vm_database | vm       | UTF8     | en_US.UTF-8 | en_US.UTF-8 |&lt;/span&gt;
&lt;span class="go"&gt;(5 rows)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;連另一個 database &lt;code&gt;vm_database&lt;/code&gt; 也很簡單，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; psql -d vm_database
&lt;span class="go"&gt;psql (9.4.5)&lt;/span&gt;
&lt;span class="go"&gt;Type &amp;quot;help&amp;quot; for help.&lt;/span&gt;

&lt;span class="go"&gt;vm_database=&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="psql_1"&gt;psql 指令&lt;/h2&gt;
&lt;p&gt;psql 的指令很多，用 &lt;code&gt;\?&lt;/code&gt; 可以看到列表。完整的版本可以見&lt;a href="http://www.postgresql.org/docs/9.4/static/app-psql.html#APP-PSQL-META-COMMANDS"&gt;官網 psql meta-commands&lt;/a&gt; 的介紹。底下列幾個常用的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\l          # list all database
\d          # list tables in current database
\du         # list roles
\conninfo   # show current SQL connection
\q          # quit
help        # print a hub message for all kinds of help
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="database_2"&gt;刪除使用者、Database&lt;/h2&gt;
&lt;p&gt;各有一個指令對應。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; dropuser &amp;lt;usr&amp;gt;
&lt;span class="gp"&gt;$&lt;/span&gt; dropdb &amp;lt;db&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_1"&gt;進階主題&lt;/h2&gt;
&lt;h3 id="psql_2"&gt;透過 psql 創建使用者帳號、資料庫&lt;/h3&gt;
&lt;p&gt;Ref: &lt;a href="http://www.cyberciti.biz/faq/howto-add-postgresql-user-account/"&gt;http://www.cyberciti.biz/faq/howto-add-postgresql-user-account/&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- Run with command `sudo -u postgres psql -d template1`&lt;/span&gt;
&lt;span class="gp"&gt;template1=#&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;USER&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="k"&gt;PASSWORD&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;pwd&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="gp"&gt;template1=#&lt;/span&gt; &lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="gp"&gt;template1=#&lt;/span&gt; &lt;span class="k"&gt;GRANT&lt;/span&gt; &lt;span class="k"&gt;ALL&lt;/span&gt; &lt;span class="k"&gt;PRIVILEGES&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="postgresql-logging"&gt;PostgreSQL Logging&lt;/h3&gt;
&lt;p&gt;設定在 &lt;code&gt;/etc/postgresql/9.4/main/postgresql.conf&lt;/code&gt; 裡。不同管理 log 的方式就要選擇不同的 &lt;code&gt;log_destination&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PostgreSQL 自己管：&lt;code&gt;stderr&lt;/code&gt;, &amp;hellip;&lt;/li&gt;
&lt;li&gt;透過 &lt;a href="http://freedesktop.org/wiki/Software/systemd/"&gt;Systemd&lt;/a&gt;：&lt;code&gt;syslog&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過我沒深入研究就是，看那個 conf 裡很多設定可以調整。設定修改後要 restart PostgreSQL cluster，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo systemctl restart postgresql.service
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id="logging-postgresql"&gt;Logging 讓 PostgreSQL 自己管&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# At /etc/postgresql/9.4/main/postgresql.conf&lt;/span&gt;
&lt;span class="na"&gt;log_destination&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;stderr&amp;#39; &lt;/span&gt;
&lt;span class="na"&gt;logging_collector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;on                              &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Log files 預設寫在 &lt;code&gt;/var/lib/postgresql/9.4/main/pg_log/&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="logging-systemd"&gt;Logging 透過 Systemd&lt;/h4&gt;
&lt;p&gt;我覺得 systemd 的優點之一就是能把 log 都集中管理，只要照它的規則，就能用一樣的方法管理 logging 是蠻方便的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# At /etc/postgresql/9.4/main/postgresql.conf&lt;/span&gt;
&lt;span class="na"&gt;log_destination&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;syslog&amp;#39;  &lt;/span&gt;
&lt;span class="na"&gt;logging_collector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;off   # on 也只會說被導向到 syslog 了                             &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這時候重啟服務，再看 &lt;code&gt;systemctl status&lt;/code&gt; 就能看到最近的 log 了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl status postgresql@9.4-main
&lt;span class="go"&gt;● postgresql@9.4-main.service - PostgreSQL Cluster 9.4-main&lt;/span&gt;
&lt;span class="go"&gt;   Loaded: loaded (/lib/systemd/system/postgresql@.service; disabled)&lt;/span&gt;
&lt;span class="go"&gt;   Active: active (running) since Mon 2016-01-25 17:52:02 CST; 1min 13s ago&lt;/span&gt;
&lt;span class="go"&gt;  Process: 14632 ExecStop=/usr/bin/pg_ctlcluster -m fast %i stop (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;span class="go"&gt;  Process: 14641 ExecStart=postgresql@%i %i start (code=exited, status=0/SUCCESS)&lt;/span&gt;
&lt;span class="go"&gt; Main PID: 14648 (postgres)&lt;/span&gt;
&lt;span class="go"&gt;   CGroup: /system.slice/system-postgresql.slice/postgresql@9.4-main.service&lt;/span&gt;
&lt;span class="go"&gt;           ├─14648 /usr/lib/postgresql/9.4/bin/postgres -D /var/lib/postgresql/9.4/main -c config_file=/etc/postg...&lt;/span&gt;
&lt;span class="go"&gt;           ├─14650 postgres: checkpointer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─14651 postgres: writer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─14652 postgres: wal writer process&lt;/span&gt;
&lt;span class="go"&gt;           ├─14653 postgres: autovacuum launcher process&lt;/span&gt;
&lt;span class="go"&gt;           └─14654 postgres: stats collector process&lt;/span&gt;

&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14648]: [1-1] 2016-01-25 17:52:00 CST [14648-1] LOG:  ending log output to stderr&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14648]: [1-2] 2016-01-25 17:52:00 CST [14648-2] HINT:  Future log output ...log&amp;quot;.&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14649]: [2-1] 2016-01-25 17:52:00 CST [14649-1] LOG:  database system was...9 CST&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14649]: [3-1] 2016-01-25 17:52:00 CST [14649-2] LOG:  MultiXact member wr...abled&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14648]: [2-1] 2016-01-25 17:52:00 CST [14648-3] LOG:  database system is ...tions&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14653]: [2-1] 2016-01-25 17:52:00 CST [14653-1] LOG:  autovacuum launcher started&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:00 vm-debian postgres[14658]: [3-1] 2016-01-25 17:52:00 CST [14658-1] [unknown]@[unknown] LOG: ...acket&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:52:38 vm-debian postgres[14793]: [3-1] 2016-01-25 17:52:38 CST [14793-1] root@root FATAL:  role &amp;quot;r...exist&lt;/span&gt;
&lt;span class="go"&gt;Hint: Some lines were ellipsized, use -l to show in full.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或用 systemd 標準看 log 的方式 &lt;code&gt;journalctl&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; journalctl -u postgresql@9.4-main 
&lt;span class="go"&gt;-- Logs begin at Mon 2016-01-25 16:46:25 CST, end at Mon 2016-01-25 19:22:07 CST. --&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13699]: [1-1] 2016-01-25 17:47:06 CST [13699-1] LOG:  redirecting log output to logging collector process&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13699]: [1-2] 2016-01-25 17:47:06 CST [13699-2] HINT:  Future log output will appear in directory &amp;quot;pg_log&amp;quot;.&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13699]: [2-1] 2016-01-25 17:47:06 CST [13699-3] LOG:  ending log output to stderr&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13699]: [2-2] 2016-01-25 17:47:06 CST [13699-4] HINT:  Future log output will go to log destination &amp;quot;syslog&amp;quot;.&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13701]: [3-1] 2016-01-25 17:47:06 CST [13701-1] LOG:  database system was shut down at 2016-01-25 17:47:05 CST&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13701]: [4-1] 2016-01-25 17:47:06 CST [13701-2] LOG:  MultiXact member wraparound protections are now enabled&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13699]: [3-1] 2016-01-25 17:47:06 CST [13699-5] LOG:  database system is ready to accept connections&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:06 vm-debian postgres[13705]: [3-1] 2016-01-25 17:47:06 CST [13705-1] LOG:  autovacuum launcher started&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:47:07 vm-debian postgres[13710]: [4-1] 2016-01-25 17:47:07 CST [13710-1] [unknown]@[unknown] LOG:  incomplete startup packet&lt;/span&gt;
&lt;span class="go"&gt;Jan 25 17:49:30 vm-debian postgres[14170]: [4-1] 2016-01-25 17:49:30 CST [14170-1] root@root FATAL:  role &amp;quot;root&amp;quot; does not exist&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-9-4-on-debian-8"&gt;How to Install and Use PostgreSQL 9.4 on Debian 8&lt;/a&gt; by Digital Ocean&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/PostgreSQL"&gt;PostgreSQL&lt;/a&gt; on Arch Wiki&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.debian.org/PostgreSql"&gt;PostgreSQL&lt;/a&gt; on Debian wiki&lt;/li&gt;
&lt;li&gt;&lt;a href="https://help.ubuntu.com/community/PostgreSQL"&gt;PostgreSQL&lt;/a&gt; on Ubuntu wiki&lt;/li&gt;
&lt;/ul&gt;</content><category term="zh"></category><category term="postgresql"></category><category term="debian"></category><category term="osx"></category></entry></feed>