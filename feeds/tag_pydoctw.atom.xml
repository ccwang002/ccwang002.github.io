<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang-Bo Wang's Blog - pydoctw</title><link href="https://blog.liang2.tw/" rel="alternate"></link><link href="https://blog.liang2.tw/feeds/tag_pydoctw.atom.xml" rel="self"></link><id>https://blog.liang2.tw/</id><updated>2022-05-13T12:58:39-05:00</updated><entry><title>Python 官方文件中文化 Server HTTPS 使用 Let's Encrypt</title><link href="https://blog.liang2.tw/posts/2016/02/pydoctw-https/" rel="alternate"></link><published>2016-02-21T14:00:00-06:00</published><updated>2022-05-13T12:58:39-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-02-21:/posts/2016/02/pydoctw-https/</id><summary type="html">&lt;p&gt;整理了 server 從 HTTP 到 HTTPS 相關設定的調整。&lt;/p&gt;</summary><content type="html">&lt;p&gt;現在可以透過 &lt;a href="https://docs.python.org.tw"&gt;https://docs.python.org.tw&lt;/a&gt; 訪問 Python 官方文件中文化網站。&lt;/p&gt;
&lt;p&gt;Server 本身的設定可以參考&lt;a href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/"&gt;之前的文章&lt;/a&gt;。加入 HTTPS 就要設定相關的憑証，我選擇 &lt;a href="https://letsencrypt.org/"&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; 做為憑証的簽署者。&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s Encrypt (LE) 使用 AMCE (Automated Certificate Management Environment) protocol 去驗証你是否擁有你欲簽証的 domain。官網上有&lt;a href="https://letsencrypt.org/howitworks/technology/"&gt;圖文說明&lt;/a&gt;，簡單來說，LE 會要求你的 server 在特定的 path 加入特定的檔案，如果你做得到，就代表你擁有這個 domain。這樣的簽証第一次要在 LE server 上註冊，之後最長每 90 天認証一次。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#lets-encrypt-certificate"&gt;Let&amp;rsquo;s Encrypt Certificate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd-timer-certificate"&gt;設定 systemd timer 定時更新 certificate&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#systemd-service"&gt;Systemd service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd-timer"&gt;Systemd Timer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#nginx-http-redirect-to-https"&gt;nginx HTTP redirect to HTTPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#https"&gt;測試 HTTPS 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;心得&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#misc"&gt;Misc.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;參考資料&lt;/h3&gt;
&lt;p&gt;我不是網路安全相關的專家，設定都是參考網路上的說明整理而成。LE certificate 的設定參考 &lt;a href="https://robmclarty.com/blog/how-to-secure-your-web-app-using-https-with-letsencrypt"&gt;&lt;em&gt;How to Secure Your Web App Using HTTPS With Letsencrypt&lt;/em&gt;&lt;/a&gt; by Rob McLarty 這篇文章。&lt;/p&gt;
&lt;h3 id="lets-encrypt-certificate"&gt;Let&amp;rsquo;s Encrypt Certificate&lt;/h3&gt;
&lt;p&gt;沒有使用 LE 官方的 client，而是用 &lt;a href="https://daylightpirates.org/"&gt;Daniel Roesler&lt;/a&gt; 所寫的 &lt;a href="https://github.com/diafygi/acme-tiny/"&gt;acme-tiny&lt;/a&gt;。這是一個不到 200 行的 Python script，可以自行檢查它有沒有做任何奇怪的事。&lt;a href="https://github.com/diafygi/acme-tiny/"&gt;acme-tiny&lt;/a&gt; 的 README 也有個設定教學，應該是大同小異。&lt;/p&gt;
&lt;p&gt;基本上都是照著 &lt;a href="https://robmclarty.com/blog/how-to-secure-your-web-app-using-https-with-letsencrypt"&gt;&lt;em&gt;How to Secure Your Web App Using HTTPS With Letsencrypt&lt;/em&gt;&lt;/a&gt; 該篇文章做，不過有調整了以下的東西：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立 letsencrypt 帳號時，禁止使用 password login。&lt;br&gt;
   即： &lt;code&gt;adduser --disabled-password ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 git 管理 &lt;a href="https://github.com/diafygi/acme-tiny/"&gt;acme-tiny&lt;/a&gt; script。&lt;/li&gt;
&lt;li&gt;改用 systemd 控制 nginx，而不是透過 service。&lt;br&gt;
   即： &lt;code&gt;systemctl reload nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;沒有用 crontab 而是使用 &lt;a href="https://wiki.archlinux.org/index.php/Systemd/Timers"&gt;systemd Timers&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;重新導引 http 連線至 https。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 4、5 點設定比較多，整理到後面。&lt;/p&gt;
&lt;h3 id="systemd-timer-certificate"&gt;設定 systemd timer 定時更新 certificate&lt;/h3&gt;
&lt;p&gt;這邊參考 &lt;a href="http://www.certdepot.net/rhel7-use-systemd-timers/"&gt;&lt;em&gt;RHEL7: How to use Systemd timers.&lt;/em&gt;&lt;/a&gt; 一文。&lt;/p&gt;
&lt;p&gt;Systemd Timer 概念如同 crontab，但差別是使用 timer 即與 systemd 整合。&lt;code&gt;&amp;lt;unit&amp;gt;.timer&lt;/code&gt; 可以定期執行 &lt;code&gt;&amp;lt;unit&amp;gt;.service&lt;/code&gt;，所以 &lt;unit&gt; 執行的結果與狀態都能顯示在 systemd 中，也帶入了 journald 有的 logging 功能。&lt;/p&gt;
&lt;p&gt;更新 certificate 的指令寫在 &lt;code&gt;/etc/letsencrypt/renew_cert.sh&lt;/code&gt;。Shell script 的內容與參考文章一樣。&lt;/p&gt;
&lt;h4 id="systemd-service"&gt;Systemd service&lt;/h4&gt;
&lt;p&gt;首先建立一個 renew_cert，以 Debian 為例放在 &lt;code&gt;/etc/systemd/system/renew_cert.service&lt;/code&gt;，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;Renew Let&amp;#39;s Encrypt cert&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog.target&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;letsencrypt&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Group&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;letsencrypt&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/etc/letsencrypt/renew_cert.sh&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;simple&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;StandardError&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;syslog&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要手動更新 certificate 的時候執行這個 service 即可，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;systemctl start renew_cert
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我們不需要 enable 它，不然每次開機都會執行一次。看結果或記錄，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;systemctl status renew_cert
journalctl -e -u renew_cert
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="systemd-timer"&gt;Systemd Timer&lt;/h4&gt;
&lt;p&gt;建立一個 &lt;code&gt;/etc/systemd/system/renew_cert.timer&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;Update Let&amp;#39;s Encrypt certificate every two months&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Timer]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;OnCalendar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;*-1/2-1 16:00:00&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;renew_cert.service&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重點只有 &lt;code&gt;[Timer]&lt;/code&gt; 這 directive。&lt;code&gt;Unit=&lt;/code&gt; 表示要啟動的 service。&lt;code&gt;OnCalendar=&lt;/code&gt;&lt;sup id="fnref:calendar"&gt;&lt;a class="footnote-ref" href="#fn:calendar"&gt;1&lt;/a&gt;&lt;/sup&gt; 則是設定這 timer 根據指定的時間點 (UTC 時間&lt;sup id="fnref:utc"&gt;&lt;a class="footnote-ref" href="#fn:utc"&gt;2&lt;/a&gt;&lt;/sup&gt;) 啟動。&lt;/p&gt;
&lt;p&gt;以這邊寫的時間 &lt;code&gt;*-1/2-1 16:00:00&lt;/code&gt; 為例，代表每年的 1+2n 月 1 日 16:00 UTC 更新 certificate，即臺灣時間 1、3、5、……月 2 日凌晨更新。&lt;/p&gt;
&lt;p&gt;啟用 timer，它需要被 enable 確保重開機時被執行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;systemctl enable renew_cert.timer
systemctl start renew_cert.timer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以用 &lt;code&gt;systemctl list-timers&lt;/code&gt; 檢查它下次執行的時間：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;sudo systemctl list-timers renew_cert.timer
&lt;span class="go"&gt;NEXT                         LEFT                LAST PASSED UNIT             ACTIVATES&lt;/span&gt;
&lt;span class="go"&gt;Tue 2016-03-01 16:00:00 UTC  1 weeks 2 days left n/a  n/a    renew_cert.timer renew_cert.service&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="nginx-http-redirect-to-https"&gt;nginx HTTP redirect to HTTPS&lt;/h3&gt;
&lt;p&gt;（這邊設定我沒信心，有更好的設定方法歡迎告訴我 &amp;gt; &amp;lt;）&lt;/p&gt;
&lt;p&gt;要解決的問題為，ACME challenge 是透過 HTTP，其餘的連線都轉到 HTTPS。&lt;/p&gt;
&lt;p&gt;在 nginx 中把主要的設定檔中拿掉 &lt;code&gt;listen 80;&lt;/code&gt; 與 ACM challenge 的部份。把它們移成新的 server block：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;server&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;listen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;server_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;docs.python.org.tw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# For Let&amp;#39;s Encrypt ACME challenge files&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/.well-known/acme-challenge/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/var/www/challenges/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;try_files&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;404&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;301&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="https"&gt;測試 HTTPS 設定&lt;/h3&gt;
&lt;p&gt;用了 &lt;a href="https://securityheaders.io/"&gt;securityheaders.io&lt;/a&gt; 和 &lt;a href="https://www.ssllabs.com/index.html"&gt;SSL Labs&lt;/a&gt; 測試了一下，應該還可以：&lt;/p&gt;
&lt;figure&gt;
  &lt;img src="https://blog.liang2.tw/posts/2016/02/pydoctw-https/pics/pydoctw_securityheaders_report.png"/&gt;
  &lt;p class="caption center"&gt;Report from securityheaders.io (&lt;a href="https://securityheaders.io/?q=https%3A%2F%2Fdocs.python.org.tw%2F3%2F"&gt;Live Report&lt;/a&gt;)&lt;/p&gt;
&lt;/figure&gt;

&lt;figure&gt;
  &lt;img src="https://blog.liang2.tw/posts/2016/02/pydoctw-https/pics/pydoctw_ssllabs_report.png"/&gt;
  &lt;p class="caption center"&gt;Report from SSL Labs (&lt;a href="https://www.ssllabs.com/ssltest/analyze.html?d=docs.python.org.tw"&gt;Live Report&lt;/a&gt;)&lt;/p&gt;
&lt;/figure&gt;

&lt;h3 id="_2"&gt;心得&lt;/h3&gt;
&lt;p&gt;總結來說，使用 &lt;a href="https://letsencrypt.org/"&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; 不難，但也沒到非常簡單。&lt;/p&gt;
&lt;p&gt;如果你願意把 root 和 private key 權限給它的話，用官方 client 提供的 &lt;code&gt;letsencrypt-auto&lt;/code&gt; 步驟能更少，用 Apache 它聲稱能全自動設定。覺得 &lt;a href="https://github.com/diafygi/acme-tiny/"&gt;acme-tiny&lt;/a&gt; 指令太複雜的話，原作者也寫了一個 &lt;a href="https://gethttpsforfree.com/"&gt;Get HTTPS for free!&lt;/a&gt; 服務，用網頁的方式協助整個註冊流程。&lt;/p&gt;
&lt;p&gt;要注意目前 public beta 階段，相同 domain 在 7 天只能被簽署 5 次，測試的時候不要太衝動不然就要等一週了。&lt;/p&gt;
&lt;h3 id="misc"&gt;Misc.&lt;/h3&gt;
&lt;p&gt;建立 CSR (Certificate Signing Request) 檔時，可以加入自己的 email 地址，不然預設是 &lt;code&gt;webmaster@&amp;lt;domain&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;openssl req -new -sha256 &lt;span class="se"&gt;\&lt;/span&gt;
    -key /etc/letsencrypt/private/domain.key &lt;span class="se"&gt;\&lt;/span&gt;
    -subj &lt;span class="s2"&gt;&amp;quot;/CN=docs.python.org.tw/emailAddress=me+pydoctw@liang2.tw&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &amp;gt; /etc/letsencrypt/private/domain.csr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:calendar"&gt;
&lt;p&gt;除了 &lt;code&gt;OnCalendar&lt;/code&gt; 還有很多設定 timer 的方式，如 &lt;code&gt;OnUnitActiveSec&lt;/code&gt;。不過其他的時間算法，都會受有沒有開機，影響時間的計算。&amp;#160;&lt;a class="footnote-backref" href="#fnref:calendar" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:utc"&gt;
&lt;p&gt;Debian Jessie 的 &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.time.html#Calendar%20Events"&gt;systemd.time (7)&lt;/a&gt; Calendar Events 裡並沒有指定時區的方式，所以加上時區會有 parse error。但新版的 systemd 似乎支援時區。總之應該用 &lt;code&gt;systemctl list-timers&lt;/code&gt; 確定執行的時間。&amp;#160;&lt;a class="footnote-backref" href="#fnref:utc" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="pydoctw"></category><category term="https"></category><category term="letsencrypt"></category></entry><entry><title>設定 Python 官方文件中文化自動更新 Server</title><link href="https://blog.liang2.tw/posts/2016/02/pydoctw-server/" rel="alternate"></link><published>2016-02-14T21:00:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-02-14:/posts/2016/02/pydoctw-server/</id><summary type="html">&lt;p&gt;設定一個自動更新 Python 說明文件中文翻譯並且 host 中文化網頁版文件的 server。使用 Django 作 web server、Django-Q 做為 task queue，deploy stack 用 nginx、uWSGI，host 於 Amazon EC2 (Debian Jessie)，資料庫用 PostgreSQL，並用 systemd 管理相關的 process。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt; 可至 &lt;a href="http://docs.python.org.tw"&gt;http://docs.python.org.tw&lt;/a&gt; 看線上自動更新的&lt;a href="http://docs.python.org.tw/3/"&gt;中文化的文件&lt;/a&gt;和 &lt;a href="http://docs.python.org.tw/_build/"&gt;build server&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;EDIT 2016-02-16: 加上 language code、git sshconfig、swap 的設定；文句潤飾。&lt;br&gt;
EDIT 2016-02-20: 加上 tmpfiles.d 的設定。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx"&gt;Sphinx 文件多國語言架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;翻譯體驗改善&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;實作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sphinx_1"&gt;Sphinx 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-django-server"&gt;Autobuild Django server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#autobuild-server"&gt;Autobuild server 部署&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;作業系統&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#postgresql"&gt;資料庫 PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#swap"&gt;Swap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-repo-ssh-config"&gt;Git repo ssh config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tmpfilesd"&gt;tmpfiles.d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#uwsgi"&gt;uWSGI 設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#systemd-services"&gt;Systemd services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;總結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="python"&gt;Python 說明文件中文翻譯計畫&lt;/h2&gt;
&lt;p&gt;最近一段時間都在準備 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件中文翻譯計畫&lt;/a&gt;。翻譯本身雖然還沒很積極地進行，但經過&lt;a href="http://www.meetup.com/Taipei-py/events/226558484/"&gt;前&lt;/a&gt;&lt;a href="http://www.meetup.com/Taipei-py/events/227001232/"&gt;幾次&lt;/a&gt; Taipei.py Projects On 的 sprint 活動，已經有蠻多人加入翻譯的行列。大家都有各自翻譯的主題，像我自己是從 &lt;a href="http://docs.python.org.tw/3/tutorial/index.html"&gt;Tutorial&lt;/a&gt; 的部份開始翻譯。&lt;/p&gt;
&lt;h3 id="sphinx"&gt;Sphinx 文件多國語言架構&lt;/h3&gt;
&lt;p&gt;先簡介一下 &lt;a href="https://docs.python.org/3/"&gt;CPython Documentation&lt;/a&gt;（下稱 pydoc）的架構和翻譯方式。pydoc 是標準的 &lt;a href="http://www.sphinx-doc.org/en/stable/"&gt;Sphinx&lt;/a&gt; 文件，因此翻譯使用 Sphinx 自帶的 &lt;a href="http://www.sphinx-doc.org/en/stable/intl.html"&gt;internationalization&lt;/a&gt; (i18n or intl) 功能把文件的內容轉換到別的語言上。&lt;/p&gt;
&lt;p&gt;如同 Django 等專案，i18n 都是透過 gettext，Sphinx 會按照 rst 檔案輸出同檔名的 po 檔。rst 檔案中的每個文字段落會對應到 po 檔一個 entry，不相干的程式碼範例等段落會被跳過。輸出的 po 檔放在對應的路徑例如 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/LC_MESSAGES/xxx.po&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Gettext"&gt;po 檔的格式&lt;/a&gt;很簡單，跳過有的沒的 header，實質內容長這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;#: ../../tutorial/appetite.rst:50&lt;/span&gt;
&lt;span class="nv"&gt;msgid&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python enables programs to be written compactly and readably.  Programs &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;written in Python are typically much shorter than equivalent C,  C++, or &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Java programs, for several reasons:&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;msgstr&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Python 讓程式寫得精簡並易讀。用 Python 實作的程式長度往往遠比用 &amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;C、C++、Java 實作的短。這有以下幾個原因：&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;實際上 Sphinx 會先輸出一份乾淨的 po 檔範本（稱為 pot 檔）到 &lt;code&gt;locale/pot/&lt;/code&gt;，基本上就是只有原文的 po 檔。每增加一個新語言就會從 pot 檔製作一份 po 檔到各自的 &lt;code&gt;locale/&amp;lt;lang&amp;gt;/&lt;/code&gt; 目錄下，翻譯時就修改那份 po 檔就可以。&lt;/p&gt;
&lt;p&gt;翻譯完成後，首先 Sphinx 會先呼叫 gettext 把 po 檔編譯成 mo 檔加速搜尋翻譯字串速度。輸出翻譯後的文件只要設定不同語言，Sphinx 就會去找該語言的 mo 檔，並把原文字串換成 mo 檔裡的內容，就可以看到中文的文件。&lt;/p&gt;
&lt;h3 id="transifex-po"&gt;Transifex 線上服務讓多人共同翻譯 po 檔&lt;/h3&gt;
&lt;p&gt;整個 Sphinx 文件翻譯流程就這樣，所以翻譯只要編輯中文 (lang code: zh-Hant&lt;sup id="fnref:zh-Hant"&gt;&lt;a class="footnote-ref" href="#fn:zh-Hant"&gt;1&lt;/a&gt;&lt;/sup&gt;) 的 po 檔就好了。不過要直接寫 po 檔格式門檻還是太高，於是就有像 &lt;a href="https://www.transifex.com/"&gt;Transifex&lt;/a&gt; 這樣的網站。上傳 po/pot 檔就能線上修改翻譯，然後再把翻完的結果用 po 檔格式下載下來。我認為這是現在參加以 gettext-based PO 檔翻譯門檻最低的方式，至少日本也是這麼做。於是想要參考 pydoc 翻譯的人，只要登入 Transifex 就可以開始編輯。&lt;/p&gt;
&lt;p&gt;用 Transifex 還有額外的好處。例如他有 POS tagging 可以標注專有名詞，定義統一的譯名，這些譯名會整理在 glossary terms 裡，翻譯時出現這些詞就會自動提示。類似的原文文句也會放在 suggestion 裡，讓翻譯完的用語文法也能一致。此外也有修改歷史、防呆提示（如該有的格式沒在譯文出現）、加註解 (comment)、評論 (issue) 等功能。&lt;/p&gt;
&lt;h3 id="_1"&gt;翻譯體驗改善&lt;/h3&gt;
&lt;p&gt;這段時間翻譯的用詞、流程等規範都有個雛型了，相關的內容都可以在&lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki"&gt;專案的 wiki&lt;/a&gt; 裡找到。所以開始想要怎麼讓大家更好參與翻譯和看到翻譯的結果。&lt;/p&gt;
&lt;p&gt;我發現參加翻譯本身已經不困難，大家沒什麼疑問。維護整體的用詞、翻譯討論用 Transifex issue 和 comment 效果不錯。整體上能保持極度分散式的工作形式。&lt;/p&gt;
&lt;p&gt;平常遇到最多問題是出現 rst 格式錯誤、缺少必要的空白、前後文加上程式碼範例之後不通順、譯文曲解或誤會原文的意思。這些問題，我覺得只要自己讀過翻完的 pydoc 該頁、看一下輸出的 log 就能明白，也不需要我多作解釋。&lt;/p&gt;
&lt;p&gt;再來，看不到自己翻譯的成果&lt;strong&gt;很沒有成就感&lt;/strong&gt;，過一段時間我怕會失去動力。&lt;/p&gt;
&lt;p&gt;於是變成需要一份保持更新的翻譯成果。當然自己輸出 doc 的方法都有寫在 &lt;a href="https://github.com/python-doc-tw/python-doc-tw/wiki/How-to-build-the-doc-locally"&gt;wiki&lt;/a&gt; 裡，但步驟很多，說簡單也沒多簡單，而且有錯或有問題可能都要來找我，就失去分散式分工的特性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不如做個 autobuild server。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;於是有了這想法。但實在是個大坑，一直只能用想的。在過年的時候總算找到時間把 prototype 做出來了，其實蠻有成就感的。&lt;/p&gt;
&lt;h2 id="pydoc-autobuild-server"&gt;PyDoc Autobuild Server&lt;/h2&gt;
&lt;p&gt;簡單整理幾個需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyDoc 結果網址對應本家 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt;。例如 /3/ 就是 Python 3.x 版最新的，而現在 /3.5/ 就會自動轉址到 /3/&lt;sup id="fnref:pydoc-url"&gt;&lt;a class="footnote-ref" href="#fn:pydoc-url"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;每一頁都有個更新翻譯連結，點一下就會從 Transifex 上抓新的翻譯，並更新輸出。&lt;/li&gt;
&lt;li&gt;更新每頁翻譯的指令輸出都要保留，方便檢查 rst 語法等錯誤。&lt;/li&gt;
&lt;li&gt;更新翻譯要有個 queue，才可以多人合作時不炸掉 autobuild server。&lt;/li&gt;
&lt;li&gt;每日更新全部的文件，並且把更新加到 CPython-tw 的 git repo 中。更新的過程一樣要有記錄。&lt;/li&gt;
&lt;li&gt;上述的所有功能都能在本機輕鬆地設定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;實作&lt;/h3&gt;
&lt;p&gt;目標就是完成上述的需求。pydoc 基本上就是個 static site，交給 nginx 設好路徑 host static files 就可以。Pydoc Sphinx 用 &lt;a href="http://jinja.pocoo.org/docs/dev/"&gt;Jinja2&lt;/a&gt; 作 HTML template，所以只要多加一些變數就能控制頁面的輸出，在 autobuild server 上時就可以加上額外的連結。而 Autobuild server 本身是個 task queue，其實功能很簡單，但為了維護方便，並考慮到 local、production 環境都要能動的話，選擇 &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; 為基礎。真的給 Django 管理的就顯示 task queue、task result、接受 rebuild doc request 這幾個 view。&lt;/p&gt;
&lt;h4 id="sphinx_1"&gt;Sphinx 文件&lt;/h4&gt;
&lt;p&gt;在 Sphinx 文件部份不想搞太複雜，就在每一頁加上一個自己的專屬連結，打這個網址就會加入一個更新該頁面的 task 到 autobuild server&lt;sup id="fnref:build-link"&gt;&lt;a class="footnote-ref" href="#fn:build-link"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;在 autobuild 時加入專屬連結只要修改 Sphinx doc template 即可。Sphinx 在 build doc 時可以透過 &lt;a href="http://www.sphinx-doc.org/en/stable/man/sphinx-build.html#options"&gt;&lt;code&gt;-A &amp;lt;name=value&amp;gt;&lt;/code&gt;&lt;/a&gt; 增加 Jinja2 template 的變數，就可控制 template render 行為：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;{# &amp;lt;cpython-src&amp;gt;/Doc/tools/templates/layout.html #}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;autobuildi18n&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/_build/update/?source_path=&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;pagename&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Update Translation&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;- &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sphinx-build -A autobuildi18n=1&lt;/code&gt; 時就會包含這個 Jinja2 block，多這個 Update Translation 連結。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sphinx-doc.org/en/stable/templating.html#pagename"&gt;&lt;code&gt;{{ pagename }}&lt;/code&gt;&lt;/a&gt; 是每頁文件的 rst 路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="autobuild-django-server"&gt;Autobuild Django server&lt;/h4&gt;
&lt;p&gt;Django server 目標就是接受 task request 和顯示 task result。一個標準的 task queue 就有這些功能。&lt;/p&gt;
&lt;p&gt;Django 上的 task queue 選擇很多，從 &lt;a href="https://www.djangopackages.com/"&gt;Django Packages&lt;/a&gt; 上的 &lt;a href="https://www.djangopackages.com/grids/g/workers-queues-tasks/"&gt;Workers, Queues, and Tasks&lt;/a&gt; 相關的套件可以看到有幾個有在更新而且 up 數多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://celery.github.io/django-celery/"&gt;django-celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://huey.readthedocs.org/en/latest/"&gt;huey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ui/django-rq"&gt;django-RQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://policystat.github.io/jobtastic/"&gt;jobtastic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扣掉不支援 Python 3 的套件&lt;sup id="fnref:python3"&gt;&lt;a class="footnote-ref" href="#fn:python3"&gt;4&lt;/a&gt;&lt;/sup&gt;後，就剩 django-celery、django-RQ、django-Q 可以選。這裡面最紅也最老牌的是 django-celery ，它與 &lt;a href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; 整合，功能完整且穩定，我用過也覺得十分不錯，缺點是功能太多有點複雜，加上不同 message queue 時會有很多設定要調整，需要一段時間上手。一般 Celery 常見的搭配使用 &lt;a href="https://www.rabbitmq.com/"&gt;Rabbit-MQ&lt;/a&gt; 和 &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;，的確在 task 很多時有必要，但我們這個 build doc 一天可能才十幾次，在不隔離 build doc 環境的情況同時間的 worker 只能有一個，不會有效能上的問題。因此我傾向只要使用與 Django 同一個 database 就好，不要再有額外非 Python 的 dependency，讓 local 開發簡單一點。&lt;/p&gt;
&lt;p&gt;最後選擇 &lt;a href="https://django-q.readthedocs.org/"&gt;django-Q&lt;/a&gt;。雖然很新但作者維護得很勤，worker 可以只用 Python 內建的 multiprocessing 完成。功能簡單卻完整，包含 monitor，跟 django-admin 整合，還可以排程。所以要啟動 django-Q 的 cluster，只要多一個 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python manage.py qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;即可，十分方便。&lt;/p&gt;
&lt;p&gt;怎麼使用 django-Q 就不在這篇 blog 討論範圍內了。我想我應該會投稿 PyCon TW 或 Taipei.py，到時候再整理成另一篇。Django-Q 的說明文件寫得很清楚，讀一讀應該就會了。&lt;/p&gt;
&lt;h2 id="autobuild-server"&gt;Autobuild server 部署&lt;/h2&gt;
&lt;p&gt;（這篇文的重點其實是部署，誰曉得背景介紹可以這麼長）&lt;/p&gt;
&lt;p&gt;部署 (deploy) 方法百百種，有好有壞。但至少要會一種嘛，所以這邊就用其中一種：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也算很流行的組合。更完整地來說，整個處理 request 的流程經過：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;web client &amp;lt;-&amp;gt; nginx web server &amp;lt;-&amp;gt; socket &amp;lt;-&amp;gt; uwsgi &amp;lt;-&amp;gt; Django server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本的設定與教學來自 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/index.html"&gt;uWSGI&lt;/a&gt; 官網的 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文，搭配 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;uWGSI and Systemd&lt;/em&gt;&lt;/a&gt; 與 &lt;a href="https://www.freedesktop.org/wiki/Software/systemd/"&gt;systemd&lt;/a&gt; 整合。&lt;/p&gt;
&lt;p&gt;這也是目前 Pydoc production 的設定，記錄一下方便未來的維護。&lt;/p&gt;
&lt;h3 id="_3"&gt;作業系統&lt;/h3&gt;
&lt;p&gt;作業系統用 Debian Jessie，架設於 Amazon EC2 上，使用 t2.nano&lt;sup id="fnref:ec2-nano"&gt;&lt;a class="footnote-ref" href="#fn:ec2-nano"&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;Python web deploy 都會把套件裝在虛擬環境中，避免不同專案間互衝或與系統衝突。在 Debian 上可以用 &lt;code&gt;apt buid-dep python3-&amp;lt;pkg&amp;gt;&lt;/code&gt; 把 Python &lt;pkg&gt; 套件所需的 header 或 library 安裝好，十分簡單。&lt;/p&gt;
&lt;h4 id="python-35-and-apt-pinning"&gt;Python 3.5 and APT-pinning&lt;/h4&gt;
&lt;p&gt;我的 code 裡用到了 &lt;a href="https://docs.python.org/3/library/subprocess.html#subprocess.run"&gt;&lt;code&gt;subprocess.run&lt;/code&gt;&lt;/a&gt;，這是 Python 3.5+ 才有的 API。但 Jessie 只有 Python 3.4，但我覺得很好用一點都不想改寫成相容舊版的 code。&lt;/p&gt;
&lt;p&gt;因此需要安裝 Debian testing channel 上最新的 Python 3.5。這樣其實有安全上的疑慮，因為只有 stable channel 才有 security support，但自己編譯的問題更大，所以像 &lt;a href="https://github.com/yyuu/pyenv"&gt;pyenv&lt;/a&gt; 這種多 Python 版本的工具不在考慮內。&lt;/p&gt;
&lt;p&gt;於是用 &lt;a href="https://wiki.debian.org/AptPreferences"&gt;Apt-Pinning&lt;/a&gt; 只讓 Python 3.5 相關的套件安裝 testing 的版本。首先把 testing channel 加到 &lt;code&gt;/etc/apt/source.list&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;deb http://cloudfront.debian.net/debian testing main
deb-src http://cloudfront.debian.net/debian testing main
deb http://security.debian.org/ testing/updates main
deb-src http://security.debian.org/ testing/updates main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然後修改 &lt;code&gt;/etc/apt/preferences&lt;/code&gt; 確定我們不會不小心裝到 testing 相關的套件，並把 Python 3.5 相關的套件設定權限 &amp;gt;= 990 讓它們能被自動安裝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Specify * rules first so later package-specfic rules can override them
Package: *
Pin: release a=testing
Pin-Priority: -10

Package: python3.5* libpython3.5*
Pin: release a=testing
Pin-Priority: 990
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以用 &lt;code&gt;sudo apt-cache policy &amp;lt;pkg-name&amp;gt;&lt;/code&gt; 檢查目前的規則會裝到哪個版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt-get update 
$ sudo apt-get install python3.5 python3.5-venv python3.5-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這樣只有 Python 3.5 相關的套件才會裝到 testing。&lt;/p&gt;
&lt;h4 id="postgresql"&gt;資料庫 PostgreSQL&lt;/h4&gt;
&lt;p&gt;資料庫用 PostgreSQL 9.4。參照之前 blog&lt;a href="https://blog.liang2.tw/posts/2016/01/postgresql-install/"&gt;《安裝 PostgreSQL 9 於 Debian Jessie / OSX》&lt;/a&gt;一文設定。&lt;/p&gt;
&lt;h4 id="swap"&gt;Swap&lt;/h4&gt;
&lt;p&gt;其實是上線不久才注意到 EC2 預設沒有 swap 空間。我很窮所以 production server 的 RAM 只有 512 MB，觀察一下有時候 build doc RAM 就全滿了，所以還是加個 swap 安心一點。&lt;/p&gt;
&lt;p&gt;因為 Amazon EBS SSD I/O 數不會另外收錢（應該吧？），就建 swap file 在主硬碟裡。&lt;/p&gt;
&lt;p&gt;Swap 設定的教學很多，這邊就參考 &lt;a href="https://wiki.archlinux.org/index.php/swap"&gt;Arch Wiki&lt;/a&gt; 上的做法，我選擇放在 &lt;code&gt;/var/swap.1&lt;/code&gt;。大小設定為 RAM 的 2 倍，即 1GB。&lt;/p&gt;
&lt;p&gt;首先把這個檔案建出來，權限改為 600。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /bin/dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/swap.1 &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;
&lt;span class="c1"&gt;# or faster with fallocate&lt;/span&gt;
sudo fallocate -l 1G /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod &lt;span class="m"&gt;600&lt;/span&gt; /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再來把這個檔案改成 swap 格式並啟用它，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /sbin/mkswap /var/swap.1
sudo /sbin/swapon /var/swap.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改 fstab 讓每次開機都有這個 swap 設定，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# /etc/fstab
/var/swap.1 none swap defaults 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用 &lt;code&gt;free -h&lt;/code&gt;、&lt;code&gt;cat /proc/meminfo&lt;/code&gt; 檢查此時應該有個 1GB swap 了。&lt;/p&gt;
&lt;h4 id="git-repo-ssh-config"&gt;Git repo ssh config&lt;/h4&gt;
&lt;p&gt;再來是 code 的同步與更新。autobuild server 只要更新 source code，但 cpython-tw source 需要定時 commit 新的翻譯，因此 deploy server 會有修改 git repo 的權限。&lt;/p&gt;
&lt;p&gt;不應該使用自己的 SSH key，deploy server 上應該有專屬的 deploy key，其中 cpython-tw 的 deploy key 有寫入權限（即可以 commit）。&lt;/p&gt;
&lt;p&gt;查了一下，要讓不同 git repo 使用不同的 SSH key 也不複雜。以這邊的例子，先修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 加入兩個新的 host，使用不同的 SSH key：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Host github-pydoc_autobuild
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.pydoc_autobuild

Host github-cpython_tw
  HostName github.com
  User git
  IdentityFile /home/pydoc/.ssh/id_rsa.cpython_tw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;建立對應的 SSH keypair，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa.pydoc_autobuild
ssh-keygen -t rsa -f ~/.ssh/id_rsa.cpython_tw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把兩個 repo 的 URL host 換掉，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git remote set-url origin git@github-pydoc_autobuild:python-doc-tw/pydoc_autobuild.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這樣兩個 repo 會透過給定的 ssh key 連線。GitHub 會顯示每個 key 最近使用的時間，檢查時間就能確認設定正確與否（而且改 host 沒設定對應該直接連不上）。&lt;/p&gt;
&lt;h4 id="tmpfilesd"&gt;tmpfiles.d&lt;/h4&gt;
&lt;p&gt;之後 nginx 和 uwsgi 溝通用的 socket 打算放在 &lt;code&gt;/run/django/xxxx.sock&lt;/code&gt; &lt;sup id="fnref:/run"&gt;&lt;a class="footnote-ref" href="#fn:/run"&gt;6&lt;/a&gt;&lt;/sup&gt;。因為只需要非 root 的權限，修改 &lt;a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html"&gt;tmpfiles.d&lt;/a&gt; 的設定，讓這個資料夾能在開機時自動建立。增加設定檔 &lt;code&gt;/etc/tmpfiles.d/pydoc_autobuild.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;d /run/django 0755 pydoc www-data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="django-stack-nginx-uwsgi"&gt;Django Stack &amp;ndash; nginx + uWSGI&lt;/h3&gt;
&lt;p&gt;在本地開發都用 &lt;code&gt;python manage.py runserver&lt;/code&gt; 啟動 Django。但上線時內建的 runserver 就無法同時間服務太多人。因此需要像 nginx、uWSGI 等工具來協助。&lt;/p&gt;
&lt;p&gt;參照 uWSGI &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html"&gt;&lt;em&gt;Setting up Django and your web server with uWSGI and nginx&lt;/em&gt;&lt;/a&gt; 一文以及 TP 寫的 《為程式人寫的 Django Tutorial》系列文中 &lt;a href="https://github.com/uranusjr/django-tutorial-for-programmers/blob/master/25-deploy-to-ubuntu-server.md"&gt;&lt;em&gt;Day 27 - Deploy to Ubuntu server&lt;/em&gt;&lt;/a&gt; 關於部署的文章。&lt;/p&gt;
&lt;p&gt;Autobuild server 有特別為 production 寫一份設定檔，切換時只要設定成 &lt;code&gt;settings.production&lt;/code&gt; 即可。在 Django 設定部份，建議把所有路徑都設成絕對路徑（包含執行檔）。不然後續在設定 systemd 要調整很多環境變數，systemd 也不會帶入使用者的 PATH 變數，不用絕對路徑其實蠻麻煩的也容易錯。&lt;/p&gt;
&lt;h4 id="nginx"&gt;nginx 設定&lt;/h4&gt;
&lt;p&gt;nginx 會接受 incoming HTTP request，需要跟 Django server 聯絡時，就會會連到 uWSGI 開的 UNIX socket。&lt;/p&gt;
&lt;p&gt;我們先假設 uWSGI 這段沒問題，首先設定 nginx 本身。由於 static files 在 nginx 就直接導到對應的檔案，不會經過 uWSGI ，所以設定好 nginx 之後 pydoc 文件本身就上線了。用這個來測試設定的正確性。&lt;/p&gt;
&lt;p&gt;對本網站而言，/static 導到 Django staticfiles；/3/、/3.5/ 導到 pydoc build HTML 的路徑；其餘路徑再交給 Django 處理。其中，/3.5/* 的連結將重新導向到 /3/* 上。&lt;/p&gt;
&lt;p&gt;整理上述的需求，寫個 nginx 設定檔在 &lt;code&gt;/etc/nginx/sites-available/pydoc_autobuild.conf&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Upstream Django setting; the socket nginx connects to&lt;/span&gt;
&lt;span class="k"&gt;upstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;server&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;unix:///run/django/pydoc_autobuild.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;listen&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;listen&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="mi"&gt;443&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;default&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;server_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;docs.python.org.tw&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="s"&gt;.69.170.26&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;charset&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="s"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;client_max_body_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;10M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# max upload size&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/path/to/code/pydoc_autobuild/assets&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/path/to/code/cpython-tw/Doc/build/html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sr"&gt;/3\.5/(.*)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;302&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/3/&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;# Finally, send all non-media requests to the Django server.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kn"&gt;location&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;django&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kn"&gt;include&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="s"&gt;/etc/nginx/uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再把檔案 soft link 到 &lt;code&gt;/etc/nginx/sites-enabled/&lt;/code&gt;，更新 nginx 設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/nginx/sites-available/
sudo ln -s pydoc_autobuild.conf ../sites-enabled/
sudo systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;確定 pydoc 上線就可以專心處理 uWSGI 了。&lt;/p&gt;
&lt;h4 id="uwsgi"&gt;uWSGI 設定&lt;/h4&gt;
&lt;p&gt;uWSGI 在 VENV 外也要裝，我覺得還是用 pip 比較簡單，雖然這樣就要自己注意 uWSGI 的版本更新了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo python3.5 -m pip install uwsgi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把 uWSGI 設定存成 &lt;code&gt;pydoc_autobuild_uwsgi.ini&lt;/code&gt; 並且在測試時，都使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo uwsgi --ini pydoc_autobuild_uwsgi.ini
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模擬實際上的執行方式，這樣之後改用 systemd 執行才不會又丟一堆權限的問題。設定檔的內容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[uwsgi]
chdir        = /path/to/code/pydoc_autobuild
# Django&amp;#39;s wsgi file
module       = pydoc_autobuild.wsgi:application
env          = DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production
# the virtualenv (full path)
home         = /path/to/VENV

# process-related settings
# master
master       = true
# maximum number of worker processes
processes    = 4
# the socket (use the full path to be safe
socket       = /run/django/pydoc_autobuild.sock
# ... with appropriate permissions - may be needed
chmod-socket = 664
uid          = pydoc
gid          = www-data
# clear environment on exit
vacuum       = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;權限上的設定可能要花點時間處理一下，nginx 使用 www-data/www-data 的身份執行，socket 要確定 nginx 能讀寫，但我的 code 放在 pydoc 使用者路徑下，用 www-data 可能會有權限的問題。建議把 uid、gid 都設定好。&lt;/p&gt;
&lt;p&gt;過程中，搭配 nginx 的錯誤訊息比較好 debug：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo less +F /var/log/nginx/error.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;成功後，再用 uWSGI 的 Emperor mode，把設定檔丟到一個路徑底下（該路徑稱為 vassals）。uWSGI 在 Emperor mode 時會自動把 vassals 路徑內所有設定檔都讀進來並執行。&lt;/p&gt;
&lt;p&gt;這裡 vassals 路徑使用 &lt;code&gt;/etc/uwsgi/vassals/&lt;/code&gt;。因為有設 uid、gid，跑的時候就不用再設了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo uwsgi --emperor /etc/uwsgi/vassals
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這樣應該 Django 相關的 view 都沒問題了。接下來，要把啟動 uWSGI 的步驟交給系統來管理。&lt;/p&gt;
&lt;h3 id="systemd-services"&gt;Systemd services&lt;/h3&gt;
&lt;p&gt;Autobuild server 包含兩個部份：Django Server 與 Django-Q cluster。所以寫成 systemd service 時會有兩個服務。&lt;/p&gt;
&lt;p&gt;Debian system service 放在 &lt;code&gt;/etc/systemd/system/&lt;/code&gt; 底下，因此建立 &lt;code&gt;uwsgi.service&lt;/code&gt; 和 &lt;code&gt;qcluster.service&lt;/code&gt; 分別管理 uWSGI Emperor mode 和 Django-Q cluster。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uwsgi.service&lt;/code&gt; 參考 uWSGI 官網 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Systemd.html"&gt;&lt;em&gt;Django and Systemd&lt;/em&gt;&lt;/a&gt; 一文的設定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=uWSGI Emperor
After=syslog.target

[Service]
ExecStart=/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals
RuntimeDirectory=uwsgi
Restart=always
KillSignal=SIGQUIT
Type=notify
StandardError=syslog
NotifyAccess=all

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;qcluster.service&lt;/code&gt; 算是自己硬寫模擬 &lt;code&gt;python manage.py qcluster&lt;/code&gt; 行為。因此環境變數都要設定好（當然用絕對路徑就沒問題了，我只是覺得這樣 build log 內的執行檔路徑都很長會很醜 xd）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[Unit]
Description=Django-Q Cluster for site pydoc_autobuild
After=syslog.target
Wants=uwsgi.service

[Service]
User=pydoc
Group=www-data
Environment=VIRTUAL_ENV=/path/to/VENV
Environment=PATH=/path/to/VENV/bin:$PATH
Environment=DJANGO_SETTINGS_MODULE=pydoc_autobuild.settings.production
WorkingDirectory=/path/to/code/pydoc_autobuild
ExecStart=/path/to/VENV/bin/python manage.py qcluster
Restart=always
KillSignal=SIGQUIT
Type=simple
NotifyAccess=none
StandardError=syslog

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這樣的設定檔應該不是 systemd 的慣例，我還在想是不是應該要改寫到 user service 去（但我不會）。&lt;/p&gt;
&lt;p&gt;加入到 systemd 之後管理就很簡單，啟動這兩個 service：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl enable uwsgi
sudo systemctl enable qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看他們的狀態：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo systemctl status uwsgi
sudo systemctl status qcluster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看它們的 log 也變得很簡單，因為有把它們的 stderr 抓起來。systemd 好處是 rotation 等等都會幫你注意，看 log 的功能也很多。&lt;/p&gt;
&lt;p&gt;例如要查最近一小時 uWSGI 的連線記錄，並在有新連線時持續更新 log：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo journalctl -xef -u uwsgi --since &amp;#39;1 hour ago&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_4"&gt;總結&lt;/h2&gt;
&lt;p&gt;介紹了 &lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;Python 說明文件翻譯計畫&lt;/a&gt;，線上文件autobuild server 基於 Django 與 Django-Q 的架構，以及在 Debian 上結合 nginx、uWSGI、systemd 的部署設定。&lt;/p&gt;
&lt;p&gt;查資料時覺得文章還不多，只有幾篇像 &lt;a href="https://luxagraf.net/src/how-set-django-uwsgi-systemd-debian-8"&gt;&lt;em&gt;How to Set Up Django with Nginx, uWSGI &amp;amp; systemd on Debian/Ubuntu&lt;/em&gt;&lt;/a&gt; 的文章，剩下要自己組裝還是要花一點時間。同時也把部署 pydoc server 的設定都記在這，將來要重建也比較簡單。&lt;/p&gt;
&lt;p&gt;關於說明文件翻譯，應該會再花篇文章好好寫整個計畫本身。&lt;/p&gt;
&lt;p&gt;（是說如果有人能從頭看到尾的話，給個回饋吧 &amp;gt; &amp;lt;）&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:zh-Hant"&gt;
&lt;p&gt;八卦是，臺灣繁體中文的 language code (or locale identifier) 究竟是 zh_TW、zh-Hant、zh-Hant-TW、zh-Hant_TW、zh_Hant 還是 zh_Hant_TW？這問題本身就可以寫一篇了。&lt;br&gt;&lt;br&gt;查國際規範 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的話，只有 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant"&gt;zh-Hant&lt;/a&gt; 和 &lt;a href="http://www.iana.org/assignments/lang-tags/zh-Hant-TW"&gt;zh-Hant-TW&lt;/a&gt;，更多關於標準的說明與定義可以參考 &lt;a href="https://www.w3.org/International/articles/bcp47/"&gt;&lt;em&gt;Understanding the New Language Tags&lt;/em&gt;, W3C&lt;/a&gt; 一文。&lt;br&gt;&lt;br&gt;不過現狀是很奇妙的。參考 OSX 定義 &lt;a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/LanguageandLocaleIDs/LanguageandLocaleIDs.html"&gt;&lt;em&gt;Language and Locale IDs&lt;/em&gt;&lt;/a&gt; 的話應該是 zh_TW、zh-Hant 或 zh-Hant_TW。而在 Debain 中，所有支援的 locale 寫在 &lt;code&gt;/usr/share/i18n/SUPPORTED&lt;/code&gt;，裡面只有 zh_TW，不過 Debian 只用 &lt;code&gt;language[_country][.charset]&lt;/code&gt; 所以不會有定義中為 script 的 Hant，雖然在 locale 中使用底線與 &lt;a href="http://www.ietf.org/rfc/bcp/bcp47.txt"&gt;BCP 47&lt;/a&gt; 的定義不同。Sphinx 透過 &lt;a href="http://babel.pocoo.org/"&gt;Babel&lt;/a&gt; 處理 locale，但它不允許 locale 中有 &lt;code&gt;-&lt;/code&gt;，因此只能考慮 zh_Hant 或 zh_Hant_TW。更有趣的是，locale 應該是 case-insensitive 所以大小寫是不重要的 XD&amp;#160;&lt;a class="footnote-backref" href="#fnref:zh-Hant" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:pydoc-url"&gt;
&lt;p&gt;其實在 &lt;a href="https://docs.python.org/"&gt;https://docs.python.org/&lt;/a&gt; 上面 &lt;a href="https://docs.python.org/3/"&gt;/3/&lt;/a&gt; 和 &lt;a href="https://docs.python.org/3.5/"&gt;/3.5/&lt;/a&gt; 是不同份文件，即使是同個版本號它們更新的時間不相同。蠻意外會是這樣的情況。不過我們不用搞這麼複雜，只要轉址就好。&amp;#160;&lt;a class="footnote-backref" href="#fnref:pydoc-url" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:build-link"&gt;
&lt;p&gt;開發時一直都是用 GET，即如文中所說，有個專屬的 link。但發現會有 robot / crawler 打這些路徑，因此最後改成 POST，把 &lt;code&gt;{{ pagename }}&lt;/code&gt; 用 data-* 即 &lt;code&gt;&amp;lt;a href="#" data-pagename="{{ pagename }}"&amp;gt;...&amp;lt;/a&amp;gt;&lt;/code&gt; 的方式存起來，在用 jQuery 綁定 click listener。&amp;#160;&lt;a class="footnote-backref" href="#fnref:build-link" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:python3"&gt;
&lt;p&gt;看 &lt;a href="https://github.com/coleifer/huey"&gt;huey&lt;/a&gt; 和 &lt;a href="https://github.com/PolicyStat/jobtastic"&gt;jobtastic&lt;/a&gt; master branch 上有 py3k 的 commit 但感覺是最近的事，有待觀察。&amp;#160;&lt;a class="footnote-backref" href="#fnref:python3" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:ec2-nano"&gt;
&lt;p&gt;吐嘈一下，t2.nano vCPU 真的時快時慢，有時 build doc 幾分鐘就搞定了，有時要幾十分鐘，有一天超慢，然後又被 web crawler 抓到，讓 task queue timeout 陷入了 timeout、restart、timeout 的無限地獄……&amp;#160;&lt;a class="footnote-backref" href="#fnref:ec2-nano" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:/run"&gt;
&lt;p&gt;/var/run = /run，這個路徑是個 tmpfs 所以每次重開機就會清空，目錄要記得重建。&amp;#160;&lt;a class="footnote-backref" href="#fnref:/run" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="pydoctw"></category><category term="python"></category><category term="django"></category><category term="postgresql"></category><category term="deploy"></category><category term="debian"></category><category term="systemd"></category><category term="nginx"></category><category term="uwsgi"></category></entry></feed>