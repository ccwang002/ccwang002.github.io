<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang-Bo Wang's Blog - labcoding</title><link href="https://blog.liang2.tw/" rel="alternate"></link><link href="https://blog.liang2.tw/feeds/tag_labcoding.atom.xml" rel="self"></link><id>https://blog.liang2.tw/</id><updated>2022-02-20T20:07:45-06:00</updated><entry><title>Coding 初學指南附錄 - Bioinfo Practices using Python</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/" rel="alternate"></link><published>2016-01-21T23:30:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-appendix-bioinfo-python/</id><summary type="html">&lt;p&gt;A walk through of practices created by Rosalind Team.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;We are going to walk through a series of practice created by &lt;a href="http://rosalind.info/problems/"&gt;Rosalind Team&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once you register an account at Rosalind, you can use their judging system to work through all problems. However, in this case you cannot arbitrarily skip easy levels and it sucks. So I&amp;rsquo;m not going to force you using the system. Luckily, in each problem one set of example data and expected output is given, which can be used for checking our answer.&lt;/p&gt;
&lt;p&gt;Note: Their code assumes Python 2 but everything I mention here is Python 3.&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python-basics"&gt;Python Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bininfo-first-try"&gt;Bininfo First Try&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#q-dna-counting-dna-nucleotides"&gt;Q DNA: Counting DNA Nucleotides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-revc-the-secondary-and-tertiary-structures-of-dna"&gt;Q REVC: The Secondary and Tertiary Structures of DNA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-gc-computing-gc-content"&gt;Q: GC: Computing GC Content&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#workthrough"&gt;Workthrough&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-next"&gt;Q: (next?)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="python-basics"&gt;Python Basics&lt;/h2&gt;
&lt;p&gt;Do their &lt;a href="http://rosalind.info/problems/list-view/?location=python-village"&gt;Python Village&lt;/a&gt; problem sets. If any topic you don&amp;rsquo;t know, go read your Python reference.&lt;/p&gt;
&lt;p&gt;Should be very trivial.&lt;/p&gt;
&lt;h2 id="bininfo-first-try"&gt;Bininfo First Try&lt;/h2&gt;
&lt;h3 id="q-dna-counting-dna-nucleotides"&gt;Q DNA: Counting DNA Nucleotides&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/dna/"&gt;http://rosalind.info/problems/dna/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: use &lt;a href="https://docs.python.org/3/library/collections.html#collections.Counter"&gt;collections.Counter&lt;/a&gt; provided by Python&amp;rsquo;s stdlib&lt;/li&gt;
&lt;li&gt;More Hint: use &lt;code&gt;' '.join&lt;/code&gt; and list comprehension to output the answer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="q-revc-the-secondary-and-tertiary-structures-of-dna"&gt;Q REVC: The Secondary and Tertiary Structures of DNA&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/revc/"&gt;http://rosalind.info/problems/revc/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: &lt;a href="https://docs.python.org/3/library/functions.html#reversed"&gt;reversed&lt;/a&gt; for any sequence object and a dict for nucleotide code mapping&lt;/li&gt;
&lt;li&gt;More Hint: done in a list comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="q-gc-computing-gc-content"&gt;Q: GC: Computing GC Content&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/gc/"&gt;http://rosalind.info/problems/gc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is the first complicated problem that some abstraction should help you come up the solution. Try write some re-usable code blocks, for example, function calls and class definitions.&lt;/p&gt;
&lt;p&gt;Don&amp;rsquo;t worry about the computation complexity&lt;/p&gt;
&lt;h4 id="workthrough"&gt;Workthrough&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;You should implement by yourself before looking my solution. Also I didn&amp;rsquo;t see their official solution so my solution can differ a lot from theirs.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Intuitively, we need to implement a FASTA file parser. FASTA contains a series of sequence reads with unique ID. From a object-oriented viewpoint, we create classes &lt;code&gt;Read&lt;/code&gt; for reads and &lt;code&gt;Fasta&lt;/code&gt; for fasta files.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Read&lt;/code&gt; is easy to design and understand,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-python"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since we need to compute their GC content, add a method for &lt;code&gt;Read&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-python"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# ... skipped&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Compute the GC content (in %) of the read.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="c1"&gt;# put the logic here (think of problem Q DNA)&lt;/span&gt;
        &lt;span class="n"&gt;gc_percent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gc_percent&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then we have to implement the FASTA parser, which reads all read entries and converts them through &lt;code&gt;Read&lt;/code&gt;. In real world we are dealing with &lt;code&gt;myfasta.fa&lt;/code&gt;-like files, but here the input is string.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-python"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Fasta&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;raw_str&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Parse a FASTA formated string.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;raw_str&lt;/span&gt;
        &lt;span class="c1"&gt;# convert string into structured reads.&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Parse the string and yield read in Read class.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="c1"&gt;# though we have no idea right now, the code structure&lt;/span&gt;
        &lt;span class="c1"&gt;# should be something like the following.&lt;/span&gt;
        &lt;span class="n"&gt;raw_lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;raw_lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here I use &lt;code&gt;yield Read(...)&lt;/code&gt;, which may be unfamiliar for Python beginners. It turns &lt;code&gt;parse(self)&lt;/code&gt; function as a generator. Generator makes you focus on the incoming data. Once data is parsed and converted, the result is immediated thrown out by &lt;code&gt;yield&lt;/code&gt;. We don&amp;rsquo;t care about how to collect all the results. In our case, we catch all the results into a list by &lt;code&gt;list(...)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So how should we read FASTA file? A simple rule in this case is that every read consists by two continuous row. Also, the first row will always be the first read id.&lt;/p&gt;
&lt;p&gt;All we need is read two lines at the same time. Here &lt;a href="https://docs.python.org/3/library/functions.html#zip"&gt;a Pythonic idiom&lt;/a&gt; is introduced. The following code read two non-overlapping lines,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-python"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;first_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw_lines&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;first_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;second_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By &lt;code&gt;zip(*[iter(s)]*n)&lt;/code&gt; magic, we are very close to implement a full parser. You could find a lot of &lt;a href="http://stackoverflow.com/a/2233247"&gt;explanations&lt;/a&gt; for this magic.&lt;/p&gt;
&lt;p&gt;Read id line percedes with a &lt;code&gt;&amp;gt;&lt;/code&gt; sign, so we could use something like &lt;code&gt;first_line[1:]&lt;/code&gt; or &lt;code&gt;first_line[len('&amp;gt;'):]&lt;/code&gt; for explicity.&lt;/p&gt;
&lt;p&gt;Then sorting the GC% of reads in a FASTA file is easy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-python"&gt;&lt;span class="n"&gt;fasta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Fasta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;...&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sorted_reads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fasta&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reads&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  &lt;span class="c1"&gt;# note 1&lt;/span&gt;
&lt;span class="n"&gt;top_gc_read&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sorted_reads&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;# note 2&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;&amp;gt;&lt;/span&gt;&lt;span class="si"&gt;{0:s}&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;{1:.6f}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;  &lt;span class="c1"&gt;# note 3, 4&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top_gc_read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;top_gc_read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code above completes the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sorted(list, key=key_func)&lt;/code&gt; sorts the list based on the return value of key_func applied to each element.&lt;/li&gt;
&lt;li&gt;or &lt;code&gt;top_gc_read = sorted(..., reversed=True)[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;two string with no operands in between will be joint automatically. In this case it is exactly &lt;code&gt;&amp;gt;{0:s}\n{1:.6f}&lt;/code&gt;. This is useful to tidy a super long string.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'...'.format()&lt;/code&gt; fills the string with given values. See &lt;a href="https://docs.python.org/3/library/string.html#formatspec"&gt;doc&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In real case FASTA can span across multiple lines, also likely the file we parse is broken. How could we modify this parser to handle these situations?&lt;/p&gt;
&lt;h3 id="q-next"&gt;Q: (next?)&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;m super tired now so I&amp;rsquo;ll leave the rest for you. Try those problems within yellow correct ratio range.&lt;/p&gt;</content><category term="Coding"></category><category term="en"></category><category term="labcoding"></category><category term="python"></category></entry><entry><title>Coding 初學指南附錄 - OSX 開發環境</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/" rel="alternate"></link><published>2016-01-21T23:00:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-appendix-osx-env/</id><summary type="html">&lt;p&gt;我自己在 OSX 上的主觀開發環境設定&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;以下的設定都蠻主觀的，見人見智。總之我把我的環境分享出來。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#terminal"&gt;Terminal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#homebrew-git-and-python"&gt;Homebrew, Git and Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#text-editors"&gt;Text Editors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#terminal-multiplexers"&gt;Terminal Multiplexers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-gui"&gt;Git GUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#documentation-searcher"&gt;Documentation Searcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#misc"&gt;Misc.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="terminal"&gt;Terminal&lt;/h2&gt;
&lt;p&gt;OSX 系統有內建一個 &lt;code&gt;Terminals.app&lt;/code&gt; 能像在 Linux 上一樣使用。他其實使用上沒什麼問題，不過想要調顏色，有更多自定功能的話，許多人會安裝 &lt;a href="http://iterm2.com/"&gt;iTerm2&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="homebrew-git-and-python"&gt;Homebrew, Git and Python&lt;/h2&gt;
&lt;p&gt;OSX 上官方沒有一個管理套件的工具，所以社群自行開發了一個叫做 Homebrew。你可以按照&lt;a href="http://djangogirlstaipei.herokuapp.com/tutorials/installation/"&gt;這篇教學&lt;/a&gt;安裝 Homebrew。&lt;/p&gt;
&lt;p&gt;裝好了之後你可以以下指令去看它該怎麼操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;$ brew --help
$ man brew    &lt;span class="c1"&gt;# for full documentation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OSX 雖然內建有 git 與 python，但我們可以用 homebrew 安裝比較標準（新）的版本，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;$ brew install git python3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果 homebrew 有問題可以用 &lt;code&gt;brew doctor&lt;/code&gt; 來檢測。把錯誤訊息問 google 通常就能找到解決方式。&lt;/p&gt;
&lt;h2 id="text-editors"&gt;Text Editors&lt;/h2&gt;
&lt;p&gt;我最常用的是 Vim。OSX 有內建，但也可以用 homebrew 安裝。&lt;/p&gt;
&lt;p&gt;除了 console based 的 Vim，OSX 上也有像 gVim 的 MacVim。一樣能用 homebrew 安裝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;$ brew info macvim  &lt;span class="c1"&gt;# 看 MacVim 在安裝有什麼選項可以調整&lt;/span&gt;
$ brew install macvim --override-system-vim --custom-icons
$ brew linkapps macvim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用 Macvim 的時候除了 vim 之外，也可以呼叫 &lt;code&gt;mvim&lt;/code&gt; 打開 MacVim。&lt;/p&gt;
&lt;h2 id="terminal-multiplexers"&gt;Terminal Multiplexers&lt;/h2&gt;
&lt;p&gt;你有可能有聽過 screen 或者 tmux。前者在 osx 上有內建但版本很舊，在顯示顏色上會有問題，因此可以透過 homebrew 再安裝新的。但因為 screen 跟系統提供的重覆到了，所以預設不在 homebrew 的 repo 中，要先新增 repo 清單：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;brew tap homebrew/dupes
brew install screen tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="git-gui"&gt;Git GUI&lt;/h2&gt;
&lt;p&gt;初學 Git 可能會不熟那些指令、常常不知道自己在 git log 哪個位置。這時候有個圖形化的工具會更方便了解。Git 有內建一個 gitk，但比較陽春。&lt;/p&gt;
&lt;p&gt;在 OSX 上可以考慮用 &lt;a href="http://www.sourcetreeapp.com/"&gt;SourceTree&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="documentation-searcher"&gt;Documentation Searcher&lt;/h2&gt;
&lt;p&gt;要一直查 Python 官網有時候還蠻麻煩的，未來學了 HTML CSS 等等不同語言或各種 Python 套件，要查個東西會很費時。所以有人開發了一個離線的 documentation 查詢器叫做 &lt;a href="http://kapeli.com/dash"&gt;Dash&lt;/a&gt;。他要錢但有免費版，似乎是會一直跳提示訊息。&lt;/p&gt;
&lt;h2 id="misc"&gt;Misc.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.alfredapp.com/"&gt;Alfred App&lt;/a&gt;：一個延伸版的 Spotlight，查應用程式很快速，同時也可以跟 Dash 整合讓查 doc 更方便。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://macdown.uranusjr.com/"&gt;Macdown&lt;/a&gt;：OSX 上的 markdown 編輯器。&lt;/li&gt;
&lt;/ul&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－Python</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/" rel="alternate"></link><published>2016-01-21T22:50:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-python/</id><summary type="html">&lt;p&gt;選擇 Python 作為第一個深入學習的語言有很多好處。他的語法跟英文相似、用互動式的方式來操作，方便以邊試邊學、內建的標準函式庫功能豐富、第三方套件，幾乎能用 Python 完成各種事情。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jun, 2017 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 是一種物件導向、直譯式的電腦程式語言，具有近二十年的發展歷史。它包含了一組功能完備的標準庫，能夠輕鬆完成很多常見的任務。&lt;/p&gt;
&lt;p&gt;(From &lt;a href="https://zh.wikipedia.org/wiki/Python"&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;選擇 Python 作為第一個深入學習的語言有很多好處。他的語法跟英文相似，比起其他語言經常用到 &lt;code&gt;;{}()&lt;/code&gt; 來控制語法不同的段落，Python 主要用的是空白與縮排。&lt;/p&gt;
&lt;p&gt;Python 能用互動式的方式（read–eval–print loop, REPL）來操作，以邊試邊做的方法來開發很適合初學者。&lt;/p&gt;
&lt;p&gt;內建的標準庫（standard library）功能很豐富，在網路、文字處理、檔案處理、甚至 GUI 介面都能用它完成。除此之外，它的第三方套件也很多，在 Linux 上很好安裝，這樣幾乎能用 Python 完成各種事情。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;聽說系列&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;聽說 Python 跑很慢，是不是不能用來計算/分析/大檔案？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-2-python-3"&gt;Python 2 還是 Python 3，聽我朋友說…比較好？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introducing-python-python"&gt;Introducing Python（精通 Python）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python_1"&gt;Python 官網&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python_2"&gt;Python 程式設計「超入門」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#learning-python"&gt;Learning Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-cookbookpython"&gt;Python Cookbook（Python 的錦囊妙計）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fluent-python-python"&gt;Fluent Python（流暢的 Python）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#moocs"&gt;MOOCs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#file-a1_python_bioinfo-md"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_1"&gt;聽說系列&lt;/h2&gt;
&lt;p&gt;（需要接觸過 Python 之後才能理解）&lt;/p&gt;
&lt;h3 id="python"&gt;聽說 Python 跑很慢，是不是不能用來計算/分析/大檔案？&lt;/h3&gt;
&lt;p&gt;Python 的確執行效率比編譯式的語言差（例：C/C++、Java），但這很可能不是你程式跑得慢的主因，所以也不代表 Python 不能處理計算量高的工作。&lt;/p&gt;
&lt;p&gt;碰到程式跑得比想像中慢的時候，有幾個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到底是哪幾行程式跑得慢？&lt;/li&gt;
&lt;li&gt;這是最佳的演算法嗎？&lt;/li&gt;
&lt;li&gt;這是最有效率的 Python 語法嗎？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果用到了最後一步情況還是沒有改善的話，就可以開始把那些部份用其他語言改寫，例如：C。Python 能很容易跟 C 語言的結合。而且常見的 C 語言加速，其實都有 Python 套件能支援了，例如 Numpy，所以大部份的時間，都能在不使用 Python 以外的語言完成高量計算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在實習時候，也常碰到需要優化的問題。用 Python 我能很輕鬆（一天內）把工作分配到 4 台主機 64 cores 上跑，也許方法不有效率，但比起我花幾天把 Python 改寫成 C/C++，實作更精密有效的算法（還要是 multithread），仔細處理可能的 corner case，平行化之後本來三四天的計算時間我 2 個小時就能收工。&lt;/p&gt;
&lt;p&gt;更重要的是，這個實驗就只跑個兩次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比起計算時間，開發時間對工程師而言是更加寶貴的。尤其在實驗室，最關心的是這個方法行不行得通，程式跑得慢有很多解決的方式，例如平行化。重點在解決問題，需要用多一點的資源其實不是很重要。&lt;/p&gt;
&lt;p&gt;如果問我 Python 還是 Matlab 比較快？這邊有正經的 &lt;a href="http://www.pyzo.org/python_vs_matlab.html"&gt;Python vs Matlab&lt;/a&gt;。一開始選 Python 慢的話有&lt;a href="http://wiki.scipy.org/PerformancePython"&gt;很多條路可以走&lt;/a&gt;，但 Matlab 呢？ meh&lt;/p&gt;
&lt;p&gt;所以 Python 跑得快不快？它單打獨鬥有極限，但它有很多快樂夥伴。O&amp;rsquo;Reilly 有本 &lt;a href="http://shop.oreilly.com/product/0636920028963.do"&gt;High Performance Python&lt;/a&gt; 值得一看。&lt;/p&gt;
&lt;h3 id="python-2-python-3"&gt;Python 2 還是 Python 3，聽我朋友說…比較好？&lt;/h3&gt;
&lt;p&gt;隨著時間流逝，每過一天我都可以更確信的說&lt;strong&gt;「請學 Python 3」&lt;/strong&gt;。現在有在用 Python 2 多半也是用 2.7 版本，要把 3.3+ 的程式碼改回 2.7 也不難。&lt;/p&gt;
&lt;p&gt;EDIT 2017-06: Python 2.7 確定&lt;a href="https://pythonclock.org/"&gt;在 2020 年會停止官方支援&lt;/a&gt;，這不代表說在那年 Python 2.7 就會瞬間消失，目前世界上有非常多公司會繼續維護他們內部的 Python 2.x 程式碼，但新的專案都預設使用 3.5+ 版本開發。而市面上的書籍也已經都是針對 Python 3.x 撰寫，過往使用中文學習的障礙已經消失。&lt;/p&gt;
&lt;h2 id="_2"&gt;相關資源&lt;/h2&gt;
&lt;p&gt;連同前幾章，如果你要在自己電腦上設定 Python 開發環境，可以參考 &lt;a href="http://djangogirlstaipei.herokuapp.com/tutorials/"&gt;Djang Girls Taipei Tutorial&lt;/a&gt;。另外，&lt;a href="http://wiki.python.org.tw/Python/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8%E5%B0%B1%E4%B8%8A%E6%89%8B"&gt;Python Taiwan Wiki&lt;/a&gt; 有更完整的 Python 學習資源列表。&lt;/p&gt;
&lt;p&gt;O&amp;rsquo;Reilly（歐萊禮）的書，&lt;a href="https://shop.oreilly.com/"&gt;官方線上商店&lt;/a&gt;常有 50% 折扣，PDF/ePub/Mobi 格式都有, 買一次就能輕鬆在電腦、Kindle、eReader 上閱讀，能接受英文的話，十分推薦跟官方購買。中文版就以&lt;a href="https://www.tenlong.com.tw/"&gt;天瓏書局&lt;/a&gt;為主。它也有賣英文紙本，逛實體店很舒服。&lt;/p&gt;
&lt;p&gt;EDIT 2017-06: 自本文撰寫兩年以來，市面上 Python 3.x 中文書已經非常充足，在天瓏實體店甚至有一整個專櫃提供不同難易度、各種應用的專書。底下列出的書只是我個人的推薦與偏好，建議有空到書店親自翻一翻更能找到自己喜歡的學習方式。&lt;/p&gt;
&lt;p&gt;除了書籍之外，現在越來越多以影片、互動形式的教學，像 Jessica McKellar 錄製的 &lt;a href="http://shop.oreilly.com/product/110000448.do"&gt;Introduction to Python&lt;/a&gt; 教學影片即非常受歡迎。因為我並沒有親自玩過這些新課程，它們並沒有列於此，但都歡迎讀者嘗試。&lt;/p&gt;
&lt;h3 id="introducing-python-python"&gt;Introducing Python（精通 Python）&lt;/h3&gt;
&lt;p&gt;O&amp;rsquo;Reilly Python 系列的書都寫得很好。這本是比較新出的，好處是它針對初學者，比較薄，能在短時間看完，文字很流暢。想要快速掌握基礎的語法的話，建議閱讀 Chp1 到 Chp7，以及 Chp8 File I/O 部份。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Introducing Python&amp;rdquo;, Bill Lubanovic. &lt;em&gt;O&amp;rsquo;Reilly&lt;/em&gt;, 2014.11&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920028659.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9863477311?item_id=1007464"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python_1"&gt;Python 官網&lt;/h3&gt;
&lt;p&gt;Python 的官網除了查語言特性之外，還能用來學習怎麼使用 stdlib。Python 標準函式庫功能包山包海，在你想要做什麼之前，都應該到官網查看看是不是內建 module 就已經提供功能了。除外，還有一個簡潔的 tutorial，供初學者參考，適合有學過其他語言的人。我認為這份寫得非常好，苦於沒有中文，據以前經驗不太容易推廣，但值得一讀。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Python Tutorial&amp;rdquo;, Official Python Documentation, Python Devs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/"&gt;連結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pythondoc.com/pythontutorial3/index.html"&gt;簡中翻譯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org.tw/3/tutorial/index.html"&gt;繁中翻譯&lt;/a&gt;（進行中）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python_2"&gt;Python 程式設計「超入門」&lt;/h3&gt;
&lt;p&gt;如果你完全沒有任何程式設計的基礎，例如不懂什麼是變數、如果寫程式控制電腦行為、什麼是命令列模式，那麼這本入門書應該很適合你。它用圖解的方式去解釋何謂迴圈、if-else 條件判斷、物件導向概念。這邊所列的其他「入門書」，都會假設你大概知道上述這些概念。到了最後兩章可能會突然變得複雜，這時候可以再回頭看看其他入門書，應該就會有辦法閱讀。&lt;/p&gt;
&lt;p&gt;《Python 程式設計「超入門」》，鎌田正浩　著、陳禹豪、林子政 譯。旗標 2016.11&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://amzn.asia/dQgghO8"&gt;日文書&lt;/a&gt; (source: Amazon)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.tenlong.com.tw/products/9789863123798"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="learning-python"&gt;Learning Python&lt;/h3&gt;
&lt;p&gt;雖然名稱看起來很像是 Python 的入門書，但它的篇幅已經來到 1600 頁，實在無法推薦給初學者。它在一本書內把 Python 幾乎所有語言特性都說清楚，同時考慮到 Python 2 和 3 版本。當你想要了解，例如 MRO 的順序、何謂 unbounded, bound method，這本書詳細的程度不會讓你失望，只怕你沒空讀。&lt;/p&gt;
&lt;p&gt;我當初看的是這一本 3ed 中文版（現已絕版），那時還沒有考慮 Python 3。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Learning Python&amp;rdquo; 5ed, Mark Lutz. &lt;em&gt;O&amp;rsquo;Reilly&lt;/em&gt;, 2013.06&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920028154.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python-cookbookpython"&gt;Python Cookbook（Python 的錦囊妙計）&lt;/h3&gt;
&lt;p&gt;這本不是入門書但很適合深入了解 Python，並讓自己的程式碼寫得更 Pythonic。裡面介紹了很多寫法慣例 idioms，同時也有中文版。非常值得在未來比較懂 Python 時買來看。&lt;/p&gt;
&lt;p&gt;作者之一 David Beazley 是 PyCon TW 2013 的 Keynote。他平常就是專門教 Python 的講師，他在 PyCon 講過的「所有 talk 與 tutorial」，如 &lt;a href="http://www.dabeaz.com/coroutines/"&gt;concurrency&lt;/a&gt;, &lt;a href="http://www.dabeaz.com/modulepackage/index.html"&gt;packaging&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=MCs5OvhV9S4"&gt;async io&lt;/a&gt; 等等都值得一看。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Python Cookbook&amp;rdquo; 3ed, David Beazley and Brian K. Jones. &lt;em&gt;O&amp;rsquo;Reilly&lt;/em&gt;, 2013.05&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920027072.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9863470686"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="fluent-python-python"&gt;Fluent Python（流暢的 Python）&lt;/h3&gt;
&lt;p&gt;當它是詳細、擴充版的 &amp;ldquo;Python Cookbook&amp;rdquo;，實際上書中也常常引用 David 的話。講述更多 Python 初介紹時不會深談的語言特性。如：MRO, Mixin, decorator, closure, metaprogramming&lt;/p&gt;
&lt;p&gt;每章最後的 Future Reading 與 Soapbox 旁徵博引，除了更細節的參考資料，還有當初 Python 為何如此設計等考量與討論的歷史、發展、與各語言比較。非常適合做為邁向 Python core developer 的參考書。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Fluent Python&amp;rdquo;, Luciano Ramalho. &lt;em&gt;O&amp;rsquo;Reilly&lt;/em&gt;, 2015.07&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920032519.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/986347911X"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="moocs"&gt;MOOCs&lt;/h3&gt;
&lt;p&gt;關於 MOOCs 我有看過 Codecademy Python Track 以及 Coursera &amp;ldquo;An Introduction to Interactive Programming in Python&amp;rdquo; 這兩門課。我覺得最大的缺點就是講 Python 2.7，Python 3.x 的好用功能與差異都沒提；再來講課的 code 範例並不是使用 idiomatic Python syntax，在初學就沒養成好習慣與慣用語法有點可惜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Codecademy Python Track &lt;a href="http://www.codecademy.com/en/tracks/python"&gt;http://www.codecademy.com/en/tracks/python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Coursera: An Introduction to Interactive Programming in Python &lt;a href="https://www.coursera.org/course/interactivepython"&gt;https://www.coursera.org/course/interactivepython&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;打開自己 Linux 裡的 Python3，跟著學習用的參考資料動手操作。用 REPL 以及運行腳本兩種方法來執行 Python 程式。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;學習使用 pip 和 venv (virtualenv) 來管理 Python 套件與環境。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: Python 官網是你的好夥伴。你可以在&lt;a href="https://docs.python.org/3/installing/"&gt;這裡 (pip)&lt;/a&gt; 和&lt;a href="https://docs.python.org/3/library/venv.html?highlight=venv"&gt;這裡 (venv)&lt;/a&gt; 找到兩者的教學。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://rg3.github.io/youtube-dl/"&gt;youtube-dl&lt;/a&gt; 是一個用來下載 Youtube、Crunchyroll 等各大影音串流網站影片的工具。除了用 Linux 的套件管理工具安裝它，它其實是個用 Python 寫成的套件。為了避免跟 Linux 系統環境相衝，請開一個 Python 虛擬環境，並在裡面用 pip 安裝它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note: youtube-dl 除了單純做下載串流檔之外，還支援轉檔、封裝、後製等影像處理，這需要 libav 或 ffmpeg 任一影像處理套件。在 Debian 系列的 Linux 上 libav 會好裝一點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 Python 解決一些實驗室會碰到的 Bioinfo 問題。有個網站 Rosalind 出了一系列的題目，我選了一些讓各位練習，請參考&lt;a href="#file-a1_python_bioinfo-md"&gt;附錄 1&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;EDIT 2016-05-22: 把 &lt;a href="https://www.ptt.cc/bbs/Python/M.1463750830.A.DA8.html"&gt;ptt 發文&lt;/a&gt; 的內容更新上來，增加一些新書和中文翻譯；調整推薦的順序。&lt;br&gt;
EDIT 2017-06-20: 更新書籍資訊與 2/3 比較。&lt;/p&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category><category term="python"></category></entry><entry><title>Coding 初學指南－版本控制</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/" rel="alternate"></link><published>2016-01-21T22:40:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-version-control/</id><summary type="html">&lt;p&gt;所謂的版本控制就跟玩遊戲一樣可以存取「進度點」，破關前都會保存進度，這樣破關失敗的時候可以還成到保存進度的狀態，再重新打怪。版本控制用在管理程式碼時，就方便讓自己在把 code 搞炸掉的時候，還能回到先前有保存的狀態。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;所謂的版本控制就跟玩遊戲一樣可以存取「進度點」，破關前都會保存進度，這樣破關失敗的時候可以還成到保存進度的狀態，再重新打怪。版本控制用在管理程式碼時，就方便讓自己在把 code 搞炸掉的時候，還能回到先前有保存的狀態。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id="_1"&gt;為什麼使用版本控制？&lt;/h3&gt;
&lt;p&gt;在軟體開發的過程中，程式碼每天不斷地產出，過程中會發生以下情況：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;檔案被別人或自己覆蓋，甚至遺失&lt;/li&gt;
&lt;li&gt;想復原前幾天寫的版本&lt;/li&gt;
&lt;li&gt;想知道跟昨天寫的差在哪裡？&lt;/li&gt;
&lt;li&gt;是誰改了這段程式碼，為什麼 ？&lt;/li&gt;
&lt;li&gt;軟體發行，需要分成維護版跟開發版&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我們希望有一種機制，能夠幫助我們：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以隨時復原修改，回到之前的版本&lt;/li&gt;
&lt;li&gt;多人協作時，不會把別人的東西蓋掉&lt;/li&gt;
&lt;li&gt;保留修改歷史記錄，以供查詢&lt;/li&gt;
&lt;li&gt;軟體發行時，可以方便管理不同版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(From: &lt;a href="http://dylandy.github.io/Easy-Git-Tutorial/"&gt;Git 教學研究站&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能做到版本控制的工具有很多，但目前主流就是 Git。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;為什麼使用版本控制？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-version-control"&gt;Git (Version Control)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;操作建議&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#commit-style"&gt;Commit Style&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;常見問題&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#conflict"&gt;Conflict&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#push-fail"&gt;Push fail&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#code-school-try-git"&gt;Code School - Try Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git"&gt;Git 教學研究站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code-school-git-real"&gt;Code School - Git Real&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#learn-git-branching"&gt;Learn Git Branching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-tutorial-by-atlassian"&gt;Git Tutorial by Atlassian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="git-version-control"&gt;Git (Version Control)&lt;/h1&gt;
&lt;p&gt;Git 是一個版本控制的工具。&lt;/p&gt;
&lt;p&gt;Git 會在你的專案（repo）目錄&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1"&gt;1&lt;/a&gt;&lt;/sup&gt;底下建一個 &lt;code&gt;.git&lt;/code&gt; 的資料夾來管理這些「進度點」，而不會去動專案其他路徑裡的東西。&lt;/p&gt;
&lt;p&gt;這些進度點可以傳到 server 上，別人下載下來的時候就可以除了得到現在的 code 以外，還能看到過去開發的記錄；而別人上傳了他的更新進度點之後，你抓下來就可以得到他更改的進度。這個就是「同步」的概念，多人之間能彼此共享、更新彼此開發的成果。&lt;/p&gt;
&lt;p&gt;能夠處理 Git 同步操作的伺服器就叫做 git server。&lt;a href="https://github.com/"&gt;Github&lt;/a&gt; 就是一間公司提供免費的 git server 讓大家同步公開的 Git 專案。很多 Linux 的工具都使用 git 來讓大家合作開發，也有不少工具已經把 git server 轉到了 Github 上面。所以非常多人在用，因此建議大家不妨申請一個 GitHub 帳號。&lt;/p&gt;
&lt;p&gt;Git 雖然最常用來管理程式碼，但它其實可以有效地管理任何純文字的檔案，也可以把 binary  檔案加到 repo 中。&lt;/p&gt;
&lt;p&gt;（可能需要有一些 git 操作經驗才能了解以下的術語）&lt;/p&gt;
&lt;h2 id="_2"&gt;操作建議&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;建立多而小的進度點&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每完成一系列的更動，就趕快 add 和 commit。一開始會煩，但這是好習慣。&lt;/p&gt;
&lt;p&gt;日後更了解 git 操作的時候，會學到一些進階的指令（如 &lt;code&gt;git rebase -i&lt;/code&gt;）就能把多個 commit 合成為一個。但要拆開一個大的 commit 會比較複雜。&lt;/p&gt;
&lt;h3 id="commit-style"&gt;Commit Style&lt;/h3&gt;
&lt;p&gt;常見的 commit message 大概會是一行文。如果這個更動需要說明，那就建議按照下面的格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行少於 50 個字元&lt;/li&gt;
&lt;li&gt;第二行留空&lt;/li&gt;
&lt;li&gt;第三行以後格式隨意，但單行不超過 75 個字元&lt;/li&gt;
&lt;li&gt;善用條列式說明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是範例（From &lt;a href="http://git-scm.com/book/ch5-2.html"&gt;Git Book&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-text"&gt;Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ps 你可以找到很多有趣的 commit message。例如：&lt;a href="http://www.commitlogsfromlastnight.com/"&gt;抱怨&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_3"&gt;常見問題&lt;/h2&gt;
&lt;h4 id="conflict"&gt;Conflict&lt;/h4&gt;
&lt;p&gt;當單機只有在一個 branch 上開發的時候，很難有 conflict 的問題。但碰到多人共同開發，或把多條 branch merge 在一起時就會有 conflict。&lt;/p&gt;
&lt;p&gt;Conflict 的發生，最常見的就是兩個人各自修改了同一個檔案相近位置的內容。這使得 git 在把兩個人的更動融合在一起的時候，會不知道到底要用誰的更動，這時候就無法自動處理了。&lt;/p&gt;
&lt;p&gt;可以搜尋「resolve git conflict」找到相關的解決辦法。&lt;/p&gt;
&lt;h4 id="push-fail"&gt;Push fail&lt;/h4&gt;
&lt;p&gt;這通常發在 server 上的進度點比自己本機的還要新，所以必須先把 server 上的更新同步下來。如果都是同一個 branch 的話，你可以試著用 &lt;code&gt;git pull --rebase&lt;/code&gt; 去避免額外的 merge。&lt;/p&gt;
&lt;h2 id="_4"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="code-school-try-git"&gt;Code School - Try Git&lt;/h3&gt;
&lt;p&gt;互動式練習，能懂最基本的 Git 指令操作，日常操作也主要是這些指令。並且會帶你建立一個 GitHub 帳號。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://try.github.io"&gt;https://try.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="git"&gt;Git 教學研究站&lt;/h3&gt;
&lt;p&gt;中文的介紹，他的互動式練習就是上面 Try Git 的中文化版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dylandy.github.io/Easy-Git-Tutorial/index.html"&gt;http://dylandy.github.io/Easy-Git-Tutorial/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code-school-git-real"&gt;Code School - Git Real&lt;/h3&gt;
&lt;p&gt;更完整的互動式練習，如果全部的關卡都做完的話，大部份需要用 git 的狀況都練習過了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://gitreal.codeschool.com"&gt;http://gitreal.codeschool.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="learn-git-branching"&gt;Learn Git Branching&lt;/h3&gt;
&lt;p&gt;顧名思義，是個練習操作 git branch 的線上學習網站。不過前幾個關卡在介紹 commit 相關的操作，可以試一試。真要練習可以先完成 Main 以下 levels：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Introduction Sequence&lt;/li&gt;
&lt;li&gt;Ramping Up&lt;/li&gt;
&lt;li&gt;Moving Work Around&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他稍難一點，視情況跳過。但如果想學 git 比較複雜的指令可以回來看它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pcottle.github.io/learnGitBranching/"&gt;http://pcottle.github.io/learnGitBranching/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="git-tutorial-by-atlassian"&gt;Git Tutorial by Atlassian&lt;/h3&gt;
&lt;p&gt;蠻完整的教學，但可能稍難一點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.atlassian.com/git/tutorials"&gt;https://www.atlassian.com/git/tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用 Git 管理這些練習的筆記（呈接在 Text Editors 的練習）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以試著對它做一些 git 指令操作：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --oneline --graph&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立 dotfiles 和 dotvim 來管理你的環境設定檔。&lt;br&gt;
   dotfiles 就是用來儲存 &lt;code&gt;.xxx&lt;/code&gt; 的檔案們，像是 &lt;code&gt;.bashrc&lt;/code&gt; 、 &lt;code&gt;.screenrc&lt;/code&gt; 、 &lt;code&gt;.tmux.conf&lt;/code&gt; 、 &lt;code&gt;.gitconfig&lt;/code&gt; 等等，一般可能存放在 &lt;code&gt;~/.xxx&lt;/code&gt; 或 &lt;code&gt;~/.config/xxx&lt;/code&gt; 之類。用版本控制的好處是，這樣在不同的 server 之間設定可以同步。&lt;br&gt;
   dotvim 是存放 &lt;code&gt;~/.vim&lt;/code&gt; 的 Vim 設定檔。這些設定檔可以透過 soft link 連結回他們原本應該在的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意！永遠不要把 private key 放入版本控制中！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 搜尋 dotfiles 就會有很多範例（Ex &lt;a href="https://github.com/ccwang002/dotfiles"&gt;我的&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立自己的 Github 帳號，並把 dotfiles / dotvim repo 同步（&lt;strong&gt;push&lt;/strong&gt;）到Github。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 建立設立好 ssh key pair 使用 ssh 上傳。Github 有&lt;a href="https://help.github.com/articles/generating-ssh-keys/"&gt;完整的教學&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;所謂的專案目錄就是下 &lt;code&gt;git init&lt;/code&gt; 指令的目錄。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－文字編輯</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/" rel="alternate"></link><published>2016-01-21T22:30:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-text-editing/</id><summary type="html">&lt;p&gt;這個章節會帶大家認識一個很簡單的純文字格式 Markdown，方便大家整理筆記。同時希望大家學會一個 terminal based 的文字編輯器，方便往後在 server 環境底下的操作。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;這個章節會帶大家認識一個很簡單的純文字格式 Markdown，方便大家整理筆記。同時希望大家學會一個 terminal based 的文字編輯器，方便往後在 server 環境底下的操作。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#markdown"&gt;Markdown&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#markdown_1"&gt;Markdown 語法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#text-editor"&gt;Text Editor&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nano"&gt;Nano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#emacs"&gt;Emacs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim"&gt;Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim_1"&gt;Vim 相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#open-vim"&gt;Open Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim-ptt"&gt;學習 Vim 的心法與攻略 (ptt)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim-adventure"&gt;Vim adventure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim_2"&gt;Vim 本身的使用手冊&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#regex"&gt;正規表示式 Regex&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#regex_1"&gt;Regex 語法派別&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#regex-one"&gt;Regex One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#regex-101"&gt;Regex 101&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="markdown"&gt;Markdown&lt;/h1&gt;
&lt;p&gt;這是一個簡便的語法，它的概念是在純文字的檔案中用一些簡單的標記，就能做出大小標題、粗斜體、超連結、表格、程式碼上色等語法。&lt;/p&gt;
&lt;p&gt;如果大家了解網頁的格式 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML"&gt;HTML&lt;/a&gt; 的話，那 markdown 的語法能直接對應到 HTML 的語法，所以這個格式在網路的世界十分流行。它的副檔名為 &lt;code&gt;.md&lt;/code&gt;，近代程式的 REAME 許多都用 markdown 寫成（例：&lt;code&gt;README.md&lt;/code&gt;）&lt;/p&gt;
&lt;h2 id="_1"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="markdown_1"&gt;Markdown 語法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://markdown.tw/"&gt;http://markdown.tw/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;這一系列的筆記就是用 markdown 寫成，你可以在&lt;a href="https://github.com/ccwang002/ccwang002.github.io/tree/src/content/blogs/2016-01"&gt;這裡&lt;/a&gt;找到它的原始檔。&lt;/li&gt;
&lt;li&gt;試著把 Linux 學習過的指令，或者自己常用的組合指令用 markdown 記錄。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="text-editor"&gt;Text Editor&lt;/h1&gt;
&lt;p&gt;在 Linux 的世界很多都是純文字檔案，再加上一些規定的語法成為新的格式。前面的 markdown 就是個例子。甚至許多可以執行的程式都只是個腳本檔，能用一般的編輯器（editor）打開就能讀懂。你可以試試&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;&lt;span class="c1"&gt;# cd is a shell script&lt;/span&gt;
nano &lt;span class="sb"&gt;`&lt;/span&gt;which &lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;       &lt;span class="c1"&gt;# thanks TP&amp;#39;s idea&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;常見的 editor 有：nano、vi、vim、emacs。到底什麼是最好用的文字編輯器，這是一場永無止盡的戰爭，近年來又有 Notepad++(GUI)、Sublime Text (GUI)、Neovim 的加入，這話題將不會有結論。對初學者而言，至少學會一個 editor 是必要的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;雖然一開始都說是介紹文字編輯器，但後來會開始學程式設計，所以最後大家在討論的都是「程式碼的編輯器」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當在編輯一些設定檔、程式碼時，為了避免打錯關鍵字但難以查覺，多數人會把程式碼的關鍵字上色。按照程式碼不同的屬性、功能上色之後，多數人發現能更好的理解程式的結構，因此 editor 大多帶有語法上色（syntax highlighting）。&lt;/p&gt;
&lt;p&gt;除了語法上色，這些 editor 都有自己的設定檔規範，可以讓使用者自行修改 editor 的行為。把自己常見的編輯器改得合乎自己習慣，是長期生活在 terminal 世界的第一步，大家可以參考（抄）別人的範本開始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;讓自己的編輯器有家的感覺。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了設定檔之外，功能多的編輯器還會有「外掛」的功能，可以讓使用者增加自己的套件。這也等大家熟悉環境之後再自行玩玩吧。&lt;/p&gt;
&lt;h2 id="nano"&gt;Nano&lt;/h2&gt;
&lt;p&gt;這是一個操作簡單好懂的編輯器，&lt;del&gt;沒有語法上色&lt;/del&gt;&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1"&gt;1&lt;/a&gt;&lt;/sup&gt;。多數的系統都有內建，所以到一個新的環境時幾乎都能使用。&lt;/p&gt;
&lt;p&gt;鳥哥有教。其實直接執行它 &lt;code&gt;nano&lt;/code&gt; 它的指令都會顯示在編輯畫面中。&lt;/p&gt;
&lt;h2 id="emacs"&gt;Emacs&lt;/h2&gt;
&lt;p&gt;抱歉，我不會。但它是一個很好的編輯器。（誠徵大大補全）&lt;/p&gt;
&lt;h2 id="vim"&gt;Vim&lt;/h2&gt;
&lt;p&gt;一個老字號但維持穩定開發的編輯器。他有個特色是編輯器的模式，有些模式能編輯文字，有些不行，但能做選取、搜尋等動作。還有特有的指令合成方式（像連續技、buff 這樣）&lt;/p&gt;
&lt;p&gt;初學者通常會難以習慣，初期不熟模式、指令記不住的話會很難操作。所以建議一開始先記住最基本的指令，隨時掌握自己在的模式，日後再慢慢加深對 vim 的了解。&lt;/p&gt;
&lt;p&gt;如果真的很沒概念，鳥哥也有寫介紹。&lt;/p&gt;
&lt;h2 id="vim_1"&gt;Vim 相關資源&lt;/h2&gt;
&lt;h3 id="open-vim"&gt;Open Vim&lt;/h3&gt;
&lt;p&gt;互動式的線上學習網站，很短，跟著操作完能會 Vim 基本動作、存檔。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.openvim.com/"&gt;http://www.openvim.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-ptt"&gt;學習 Vim 的心法與攻略 (ptt)&lt;/h3&gt;
&lt;p&gt;了解最常用的 normal 與 insert 模式及最基本的指令。這篇的內容理解之後，就能用 vim 處理文字編輯了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/Editor/M.1264056747.A.885.html"&gt;https://www.ptt.cc/bbs/Editor/M.1264056747.A.885.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-adventure"&gt;Vim adventure&lt;/h3&gt;
&lt;p&gt;如果很難學習 &lt;code&gt;hjkl&lt;/code&gt;、&lt;code&gt;wb&lt;/code&gt; 移動的話，這是個要用 vim 指令控制的小遊戲。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://vim-adventures.com/"&gt;http://vim-adventures.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim_2"&gt;Vim 本身的使用手冊&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;vimtutor&lt;/code&gt; 指令，或者在 vim normal 模式時鍵入 &lt;code&gt;:help&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;能在 terminal 中編修一個文字檔名為 &lt;code&gt;foo.txt&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try nano&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nano foo.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭配 root 權限修改系統的設定檔（你在鳥哥可能有經驗了）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try sudo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能在 console 中編寫程式碼。用 1. 的方案也可，但建議再試試看另外一個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try vi, vim or emacs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 editor 設定讓它更符合自己的習慣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: for vim, try editing &lt;code&gt;~/.vimrc&lt;/code&gt;; for emacs, try editing &lt;code&gt;~/.emacs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 terminal editor 使用 markdown 格式記錄這些練習的筆記與答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="regex"&gt;正規表示式 Regex&lt;/h1&gt;
&lt;p&gt;Vim 在 normal 模式下能用 &lt;code&gt;/{pattern}&lt;/code&gt; 搜尋文中的字串。除了直接把想要查的字串寫在 pattern 裡以外，還可以設計規則找出符合 pattern 但不一樣的結果。這樣的規則稱之為正規表示式（Regular Expression, or regex）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想做很複雜的字串比對時，都應該考慮是否能使用 regex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要做字串比對的地方，工具通常都會提供使用 regex，例如 &lt;code&gt;grep&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;。Vim 與 Python 也都有提供 regex 的功能。&lt;/p&gt;
&lt;h3 id="regex_1"&gt;Regex 語法派別&lt;/h3&gt;
&lt;p&gt;既然 regex 是一套字串比對的規則，就有規範它的語法。主要的 regex 語法有兩大類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRE (basic regex)&lt;ul&gt;
&lt;li&gt;Ex. &lt;code&gt;[:alnum:]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ERE (extended regex)&lt;ul&gt;
&lt;li&gt;Ex. &lt;code&gt;\w&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Linux 指令當中通常會因為使用 regex 語法的不同分成多個指令&lt;sup id="fnref:註2"&gt;&lt;a class="footnote-ref" href="#fn:註2"&gt;2&lt;/a&gt;&lt;/sup&gt;。例如 grep 使用 BRE；egrep 使用 ERE。&lt;/p&gt;
&lt;p&gt;與文字編輯相關的工具，像 Vim、Python、Perl&lt;sup id="fnref:註3"&gt;&lt;a class="footnote-ref" href="#fn:註3"&gt;3&lt;/a&gt;&lt;/sup&gt; 也有他們各自寫 regex 的方式，但多少都與前兩大類相似，使用時都應該先查一下他們的語法。Vim 可以用 &lt;code&gt;:help regex&lt;/code&gt; 查看。&lt;/p&gt;
&lt;h2 id="_4"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="regex-one"&gt;Regex One&lt;/h3&gt;
&lt;p&gt;主要是介紹 pcre 的語法，每一個 example 多介紹一個新的語法。接著還有個 practical examples 練習整理不同的語法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://regexone.com/"&gt;http://regexone.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regex-101"&gt;Regex 101&lt;/h3&gt;
&lt;p&gt;regex 很容易寫到自己都看不懂，這是一個幫助了解自己或別人寫好的 regex pattern 的網站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://regex101.com/"&gt;https://regex101.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;nano 其實有辦法做語法上色喔，詳見 &lt;a href="https://wiki.archlinux.org/index.php/Nano"&gt;Arch wiki&lt;/a&gt; 及 &lt;a href="https://github.com/scopatz/nanorc"&gt;nanorc&lt;/a&gt;。Thanks @concise&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註2"&gt;
&lt;p&gt;哪些指令有無支援 regex 以及支援的語法可以參考 &lt;a href="https://www.debian.org/doc/manuals/debian-reference/ch01.en.html#_unix_text_tools"&gt;Debian Reference&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:註2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註3"&gt;
&lt;p&gt;Perl 的 regex 語法又稱為 &lt;strong&gt;pcre&lt;/strong&gt; style，常被其他工具使用。例如：php&amp;#160;&lt;a class="footnote-backref" href="#fnref:註3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－Linux</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/" rel="alternate"></link><published>2016-01-21T21:30:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-linux/</id><summary type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;學習使用 Linux 是第一個比較大的障礙，因為會在短時間接觸到非 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016 （如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;學習使用 Linux 是第一個比較大的障礙，因為會在短時間接觸到非常多新的東西。後面的東西多少都與 Linux 相關，而 Linux 難的部份在開始使用 terminal 來操作「整台電腦」，對很習慣使用視窗介面的人會覺得很不直覺。好在近年幾個主流的 Linux Distribution 都有很好的圖形介面（正確稱 Desktop Environment），所以一開始能漸近地適應 terminal 操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在實驗室 server 上開發，「能在 terminal 裡做事情」是必須的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#linuxunixbsdnix"&gt;Linux、Unix、BSD、*nix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#distro"&gt;Distro 簡介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#redhat-centos-fedora"&gt;Redhat / CentOS / Fedora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debian-ubuntu"&gt;Debian / Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#archlinux"&gt;ArchLinux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#gnomekdexfcelxde"&gt;桌面環境 GNOME、KDE、XFCE、LXDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;鳥哥的私房菜&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;各章節重點整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#introduction-to-linux-on-edx-course"&gt;Introduction to Linux on edX course&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debian-user-manual"&gt;Debian User Manual&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#chapter-highlights"&gt;Chapter Highlights&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他 Coding 初學指南系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="linuxunixbsdnix"&gt;Linux、Unix、BSD、*nix&lt;/h2&gt;
&lt;p&gt;Linux 和 Unix 是不同的，但對初學者來說他們的分別不容易查覺，兩者的終端指令很相似，也因此有了 *nix 的通稱。Linux 介紹書多半會把他們的歷史好好的說一遍&lt;sup id="fnref:註2"&gt;&lt;a class="footnote-ref" href="#fn:註2"&gt;1&lt;/a&gt;&lt;/sup&gt;，有興趣聽軟體發展故事的就多留意這部份。&lt;/p&gt;
&lt;p&gt;不完整地主要分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redhat, CentOS, Fedora&lt;/li&gt;
&lt;li&gt;Debian, Ubuntu, Linux Mint&lt;/li&gt;
&lt;li&gt;ArchLinux&lt;/li&gt;
&lt;li&gt;openSUSE&lt;/li&gt;
&lt;li&gt;FreeBSD, OpenBSD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些 distributions (distros)。其實 Linux、BSD (or Unix) 的系統非常多&lt;sup id="fnref:註3"&gt;&lt;a class="footnote-ref" href="#fn:註3"&gt;2&lt;/a&gt;&lt;/sup&gt;，但對初入 Linux 的使用者，應該要找比較熱門的 distro 使用，才好找資料。&lt;/p&gt;
&lt;p&gt;上面條列的方式是有意義的，我把類似的 distro 放在同一排，只要學了其中一個，同排的其他都很好上手。其中前兩排是兩大家族反映兩種生態。我們實驗室的大 server 用的是 CentOS；但近年來我自己的電腦已經漸漸換到 Debian 上。&lt;/p&gt;
&lt;h2 id="distro"&gt;Distro 簡介&lt;/h2&gt;
&lt;p&gt;以下是我不負責任的主觀介紹。從介紹篇幅就知道我是個傾向 Debian 的人。&lt;/p&gt;
&lt;h4 id="redhat-centos-fedora"&gt;Redhat / CentOS / Fedora&lt;/h4&gt;
&lt;p&gt;Redhat 是商用的版本，開源社群維護的對應版本是 CentOS。它以保守穩定著名，但相對來說新的東西在上面就要自己安裝，這對實驗室都用較新的工具來說是個減分的地方。他套件用 &lt;code&gt;yum xxx&lt;/code&gt; 來操作。Fedora 上的東西會新一點但我們實驗室沒人用，所以不建議。&lt;/p&gt;
&lt;h4 id="debian-ubuntu"&gt;Debian / Ubuntu&lt;/h4&gt;
&lt;p&gt;Debian 是另一個大家族的頭，雖然是頭但一直保持穩定開發，在說明文件、&lt;a href="https://wiki.debian.org/"&gt;wiki&lt;/a&gt; 上都有不錯的品質。本身有所謂的 stable、testing、unstable 並分別對應三個版本號碼與名稱。以 2016.01 為例，stable 是 jessie(8)、testing 是 stretch(9)。unstable 永遠對應到 sid。如字面上的意思代表當中套件（軟體）的新舊程度。stable 上的工具也因此會比較舊不適合實驗室使用，但 testing 還蠻適合的，我個人很推。套件用 &lt;code&gt;apt-get xxx&lt;/code&gt; 來操作。&lt;/p&gt;
&lt;p&gt;Debian 家族中的 Ubuntu 非常火紅，網路上教學非常多，背後也有公司加持。基本上 Debian 的優點都會傳到 Ubuntu 上。Ubuntu 雖然套件包等等都從 Debian 移植，但他有自己的版本號碼，每半年發佈一個版本。&lt;/p&gt;
&lt;h4 id="archlinux"&gt;ArchLinux&lt;/h4&gt;
&lt;p&gt;再來的有興趣自己看，但我要額外介紹一個 ArchLinux。這是一個很自幹的系統，一點都不適合新手與懶人。但他有一個寫得很仔細完整的 &lt;a href="https://wiki.archlinux.org/"&gt;wiki 站&lt;/a&gt;。想要學新的套件、不會設定的話，去問 google 的時候請優先看他們的 wiki。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查資料的時候，除了 StackOverflow 、Ubuntu 論壇之外，請多看品質優良的 &lt;a href="https://wiki.archlinux.org/"&gt;Arch Linux&lt;/a&gt; 和 &lt;a href="https://wiki.debian.org/"&gt;Debian&lt;/a&gt; 的 wiki。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;寫了這麼多，沒有給一個明確的選擇，多數人還是很難決定。所以如果你是初學者，我會建議安裝 Ubuntu，在此時請選擇 &lt;a href="http://releases.ubuntu.com/15.10/"&gt;15.10&lt;/a&gt; or &lt;a href="http://releases.ubuntu.com/14.04/"&gt;14.04 LTS&lt;/a&gt; Desktop 版本，因為他網路上的資源最豐富。&lt;/p&gt;
&lt;p&gt;但我不是很喜歡 Ubuntu，所以等你有能力自己查詢 Linux 相關操作時，建議再看看別的 distro （例如我推薦的 &lt;a href="https://www.debian.org/releases/testing/"&gt;Debian testing channel&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id="gnomekdexfcelxde"&gt;桌面環境 GNOME、KDE、XFCE、LXDE&lt;/h2&gt;
&lt;p&gt;圖形化介面（GUI），除了使用者的應用程式外，還需要系統輔助、管理等核心套件。一系列的 GUI 套件就稱之為桌面環境。&lt;/p&gt;
&lt;p&gt;Windows、OSX 在安裝系統時都會自動安裝， 即桌面環境只有一種選擇。但在 Linux 上，GUI 的安裝是選擇性的，系統能在只有單純的 terminal 介面便能完整使用（例如選擇安裝 Ubuntu Server 時），不少 server 為了效能、安全性的考量都不會裝桌面環境。&lt;/p&gt;
&lt;p&gt;對 Linux 來說桌面環境是能之後再選擇安裝上去的，而且還有「不同口味」可以選擇，使用者也可以自由的移除它們（但很有可能會炸掉），常見就有 GNOME、KDE、XFCE、LXDE&lt;sup id="fnref:註4"&gt;&lt;a class="footnote-ref" href="#fn:註4"&gt;3&lt;/a&gt;&lt;/sup&gt; 幾種系統能使用。例如選擇安裝 Ubuntu Server 後，想要再加上 GNOME 列圖形化介面時，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="language-bash"&gt;sudo apt-get install ubuntu-gnome-desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這邊不會去細講這些實作方式的不同。簡單而言，GNOME 最流行。XFCE 使用的系統資源較少，在實驗室上的 server 常會裝這個。在 Ubuntu 上，預設是用 Unity，它是從 GNOME 沿伸出來的。&lt;/p&gt;
&lt;p&gt;第一次安裝時，就使用預設的模式吧。裝好之後要換到不同的桌面環境時，需要對套件管理系統（例 apt、yum）、調整系統設定有足夠了解。&lt;/p&gt;
&lt;h2 id="_1"&gt;相關資源&lt;/h2&gt;
&lt;p&gt;認真地說，我有點不知道 Linux 從很初學到完整學習的資源在哪裡。如果你們在學的過程中，有碰到更適合的請再告訴我（例如：留言）&lt;/p&gt;
&lt;h3 id="_2"&gt;鳥哥的私房菜&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://linux.vbird.org/linux_basic/"&gt;鳥哥官網（基礎學習篇）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9861818510?item_id=53725"&gt;實體書連結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在台灣學 Linux 大概都會先推薦鳥哥，這應該是最多人用的完整中文資源了。如果願意啃完他，對 Linux 絕對會有足夠的認識。我大學的時候也是看這本入門的。&lt;/p&gt;
&lt;p&gt;不適合的地方是鳥哥介紹 Redhat 系的操作，很多設定在 Ubuntu 上不需要或者是用別的方式去管理。例如，在 CentOS 上可能都用文字檔來修改設定，但在 Ubuntu 上可以用 &lt;code&gt;dpkg-reconfigure&lt;/code&gt; 指令來更動。他示範的 OS 為 CentOS 5.x，現在 CentOS 已經 7.x 版了，許多設定也過時了，新的工具不會介紹到。&lt;/p&gt;
&lt;p&gt;例如現在安裝 Linux 時，在磁區分割上都有很好的預設值，初學者可以不用再學調整 swap 等設定。同時系統也都提供使用 LVM (Logical Volume Manager) &lt;sup id="fnref:註5"&gt;&lt;a class="footnote-ref" href="#fn:註5"&gt;4&lt;/a&gt;&lt;/sup&gt; 管理磁區，這些磁區 (LV) 日後能動態調整。換句話說，第五章（含）的內容都與現在使用 Linux 的方式不同，如果只是順著鳥哥書的順序一章一章看下來，會沒辦法對照自己系統操作，因為近期的 Linux 安裝只要很順的下一步就能完成了。&lt;/p&gt;
&lt;h4 id="_3"&gt;各章節重點整理&lt;/h4&gt;
&lt;p&gt;鳥哥的內容退一千步來說都對初學者很有幫助，但為了避免各位花費無謂的時間在「對照古早與現代操作 (google 到的資料)上」，整理個表格讓大家知道每個章節什麼地方需要看。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;章節&lt;/th&gt;
&lt;th align="left"&gt;章節名&lt;/th&gt;
&lt;th&gt;重要的內容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="left"&gt;計算機概論&lt;/td&gt;
&lt;td&gt;沒聽過 CPU、RAM、MB GB 單位就從頭看； 不然就讀資料表示方式(3)、軟體程式運作(4)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="left"&gt;首次登入與線上求助 man page&lt;/td&gt;
&lt;td&gt;文字模式下指令的下達(2)、man page 與 info page(3)、nano(4)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="left"&gt;Linux 的檔案權限與目錄配置&lt;/td&gt;
&lt;td&gt;全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="left"&gt;Linux 檔案與目錄管理&lt;/td&gt;
&lt;td&gt;除檔案隱藏與特殊屬性(4)外都重要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;8&lt;/td&gt;
&lt;td align="left"&gt;Linux 磁碟與檔案系統管理&lt;/td&gt;
&lt;td&gt;檔案系統的簡單操作(2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;td align="left"&gt;檔案與檔案系統的壓縮與打包&lt;/td&gt;
&lt;td&gt;壓縮檔案的用途與技術(1)、打包指令(3)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;10&lt;sup id="fnref:*"&gt;&lt;a class="footnote-ref" href="#fn:*"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td align="left"&gt;vim 程式編輯器&lt;/td&gt;
&lt;td&gt;語系編碼轉換(4.3)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;11&lt;/td&gt;
&lt;td align="left"&gt;認識與學習 BASH&lt;/td&gt;
&lt;td&gt;全。但可視情況忽略 2.4-2.8、6.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;12&lt;sup id="fnref:†"&gt;&lt;a class="footnote-ref" href="#fn:†"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td align="left"&gt;正規表示法與文件格式化處理&lt;/td&gt;
&lt;td&gt;前言(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;13&lt;/td&gt;
&lt;td align="left"&gt;學習 Shell Scripts&lt;/td&gt;
&lt;td&gt;全（等用到再看）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="left"&gt;軟體安裝：原始碼與 Tarball&lt;/td&gt;
&lt;td&gt;全（了解流程、懂有這些關鍵字就好）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;td align="left"&gt;軟體安裝： RPM, SRPM 與 YUM 功能&lt;/td&gt;
&lt;td&gt;Ubuntu 用的是 APT&lt;sup id="fnref:‡"&gt;&lt;a class="footnote-ref" href="#fn:‡"&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="introduction-to-linux-on-edx-course"&gt;Introduction to Linux on edX course&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.edx.org/course/introduction-linux-linuxfoundationx-lfs101x-2"&gt;課程連結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux Foundation 所開辦的線上課程，有英文的影片和講義。還請到了 Linux Kernel 的作者 Linus Torvalds 來拍介紹片。這是真的從非常基礎開始講，我有稍微看過，但我怕難度不夠，需要再搭配其他的資源來使用。好處是初期的學習比讀鳥哥前幾章來的快非常多（鳥哥前幾章為計算機概論）。&lt;/p&gt;
&lt;h3 id="debian-user-manual"&gt;Debian User Manual&lt;/h3&gt;
&lt;p&gt;英文的 Debian 系統使用者手冊，裡面包含了常見問題排解、各種硬體上的安裝指南、參考手冊。想要好好學習現代 Debian (Linux) 的使用方式的話，可以參考這些資源，它們還有再維護。&lt;/p&gt;
&lt;p&gt;缺點是這手冊太長了，如果有碰到什麼特別想了深入了解的，建議可以看這個。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.debian.org/doc/user-manuals"&gt;https://www.debian.org/doc/user-manuals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.debian.org/doc/manuals/debian-reference/index.en.html"&gt;Debain Reference&lt;/a&gt; (online HTML)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="chapter-highlights"&gt;Chapter Highlights&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Chp. No&lt;/th&gt;
&lt;th align="left"&gt;Chp. Name&lt;/th&gt;
&lt;th align="left"&gt;Highlights&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;1&lt;/td&gt;
&lt;td align="left"&gt;GNU/Linux tutorials&lt;/td&gt;
&lt;td align="left"&gt;Everything except for 1.3 Midnight Commander&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;Debian package management&lt;/td&gt;
&lt;td align="left"&gt;Read 2.2 Basic package management operations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;10&lt;/td&gt;
&lt;td align="left"&gt;Data management&lt;/td&gt;
&lt;td align="left"&gt;Read 10.1 Sharing, copying, and archiving&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_4"&gt;學習目標&lt;/h2&gt;
&lt;p&gt;因為這邊指的 Linux 算是一個蠻廣的內容，一開始學的時候很容易迷失方向。所以我額外列了幾個很重要的觀念，你應該能在學習 Linux 的初期接觸到他們：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解 &lt;code&gt;$PATH&lt;/code&gt; 與程式執行位置的關係&lt;ul&gt;
&lt;li&gt;為什麼打 &lt;code&gt;ls&lt;/code&gt; 可以找到這隻名為 &lt;code&gt;ls&lt;/code&gt; 的程式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;知道 stdin、stdout、stderr；pipeline 的使用&lt;/li&gt;
&lt;li&gt;知道環境變數是什麼，怎麼修改&lt;/li&gt;
&lt;li&gt;了解檔案、目錄、相對路徑；權限設定&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;&amp;lt;cmd&amp;gt; -h&lt;/code&gt; &lt;code&gt;&amp;lt;cmd&amp;gt; --help&lt;/code&gt; &lt;code&gt;man &amp;lt;cmd&amp;gt;&lt;/code&gt; 來查看指令的功能、可下的參數&lt;ul&gt;
&lt;li&gt;&amp;lt;cmd&gt; = 任何在 linux 下的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你花了一個禮拜的時間，但上述的內容連聽都沒聽過（或沒什麼使用到），那很可能你學習 Linux 的方式跟我想得很不一樣，請先寫個信告訴我。上面這些觀念的學習也是漸近式的，過了一個禮拜只有聽過但不是很了解，這是很正常的現象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己從零開始安裝一次 Linux 系統（可以用 VM）。&lt;/li&gt;
&lt;li&gt;定期使用它一個星期以上（即熟悉 &lt;code&gt;cd&lt;/code&gt; &lt;code&gt;ls&lt;/code&gt; 等基礎指令）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 ssh 連線到遠端的 Linux。（要打開 ssh 的 port）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus: 在 ssh 連線時不用打密碼。&lt;/li&gt;
&lt;li&gt;Bonus hint: 查 &lt;code&gt;authorized_keys&lt;/code&gt;。會需要建立 ssh user identity keypair，這會在上傳 GitHub 時用到）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝一個叫 &lt;a href="http://hisham.hm/htop/"&gt;htop&lt;/a&gt; 的系統監控軟體。使用它來查看系統資料的使用狀況&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus:&lt;ul&gt;
&lt;li&gt;調整欄位的排版&lt;/li&gt;
&lt;li&gt;開啟 Tree Veiw&lt;/li&gt;
&lt;li&gt;選擇顯示單一使用者運行的程序（太舊的 htop 可能沒這功能）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝一個叫 &lt;a href="http://aria2.sourceforge.net/"&gt;aria2&lt;/a&gt; 的續傳軟體，他可以多線程下載 HTTP(S)、FTP、甚至 BT。今天想要下載 Debian Jessie netinst 的映像檔，使用 2 個線程同時下載。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 查 &lt;code&gt;aria2c&lt;/code&gt; 的 man page。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;學會查看系統硬碟的使用量；查看當前目錄內所有檔案的大小（絕對不是 &lt;code&gt;ls -l&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: &lt;code&gt;df&lt;/code&gt; 和 &lt;code&gt;du&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scp 是個透過 ssh 傳送一或多個檔案的指令，試著用它把自己電腦的檔案（們）傳到 server 上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus:&lt;ul&gt;
&lt;li&gt;在路徑中搭配特殊字元 &lt;code&gt;*?&lt;/code&gt; 傳多個檔案&lt;/li&gt;
&lt;li&gt;有一個更精密的傳檔工具叫 rsync，試著改用它來傳檔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 GUI 的遠端介面。這相關的技術有很多：VNC、RDP 最常見。RDP 在 windows 連接上比較順暢；VNC 在畫面傳輸比較沒效率，這會對 server 造成不小的負擔，也很容易 lag。有一個新的通訊協定叫 NX，它對畫面壓縮使用即便網速很慢依然能使用圖形介紹。&lt;br&gt;
   試著用實作 NX 協定的軟體 X2go 做遠端桌面連線到 server。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 你需要在 server 與 client 端（通常是自己的電腦）都裝上 X2go 的軟體，並會使用到 SSH 的連線設定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只用 Linux 生存一個星期以上（包含中文輸入、上網等等）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:註2"&gt;
&lt;p&gt;Linux distros 源流 &lt;a href="http://en.wikipedia.org/wiki/Linux_distribution"&gt;http://en.wikipedia.org/wiki/Linux_distribution&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:註2" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註3"&gt;
&lt;p&gt;&lt;a href="http://distrowatch.com/"&gt;Distro Watch&lt;/a&gt; 是一個介紹各種 Linux、BSD 系統的地方，可以來這邊看各個 distro 的介紹。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註3" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註4"&gt;
&lt;p&gt;LXDE 原作者是 PCMan 喔，也有相當多的台灣人在維護它。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註4" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註5"&gt;
&lt;p&gt;LVM 不懂沒關係，有興趣可以參考&lt;a href="http://linux.vbird.org/linux_basic/0420quota.php#lvm"&gt;鳥哥十五章&lt;/a&gt;、&lt;a href="https://wiki.archlinux.org/index.php/LVM"&gt;Arch Wiki&lt;/a&gt; 介紹&amp;#160;&lt;a class="footnote-backref" href="#fnref:註5" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:*"&gt;
&lt;p&gt;學 vim 有別的資源，詳見 &lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;2 Text Editing&lt;/a&gt;。&lt;br&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:*" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:†"&gt;
&lt;p&gt;正規表示（regex）很重要，但初學 Linux 時會覺得很複雜可以跳過。 &lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;2 Text Editing&lt;/a&gt; 會再接觸到一次 vim 的 regex、&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;4 Python&lt;/a&gt; 也會學到 Python 的 regex，可以等到時候再回來學 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;egrep&lt;/code&gt; 等指令。&lt;br&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:†" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:‡"&gt;
&lt;p&gt;APT 的使用教學可以參考 &lt;a href="https://help.ubuntu.com/community/AptGet/Howto"&gt;Ubuntu 官網&lt;/a&gt;、&lt;a href="http://blog.longwin.com.tw/2005/05/use_apt/"&gt;網路上大大的筆記&lt;/a&gt;。&amp;#160;&lt;a class="footnote-backref" href="#fnref:‡" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－總章</title><link href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/" rel="alternate"></link><published>2016-01-21T21:00:00-06:00</published><updated>2022-02-20T20:07:45-06:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2016-01-21:/posts/2016/01/lab-coding-intro/</id><summary type="html">&lt;p&gt;給實驗室新生，了解當今軟體開發流程及基本技能的背景知識與初步技能樹。&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last Edited: Jan, 2016&lt;/p&gt;
&lt;p&gt;（如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;雖然實驗室不是正規寫程式的地方，多數的人也沒把寫程式當成一回事。不過隨著要分析的資料、樣本數越來越多，多到自己電腦跑不動，server 也要跑很久的時候，就會顯示出程式的重要性。另一方面，現在的研究講求 &lt;em&gt;reproducibility&lt;/em&gt;，如果要讓自己的分析在一年之後也能重現，或者讓世界上其他的研究者也能重現的話，需要基本的程式技巧。&lt;/p&gt;
&lt;p&gt;這一系列的文章，目標讓實驗室的新生，不論是不是 CS 背景，都能了解當今軟體開發流程及基本技能。軟體開發需要一些背景知識，才能與開發者正常交流。這些背景知識包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉在 server 上工作（或 Linux 的使用）&lt;/li&gt;
&lt;li&gt;一個很多人用的軟體工具長什麼樣&lt;/li&gt;
&lt;li&gt;如何把自己的程式與別人分享&lt;/li&gt;
&lt;li&gt;多人共同開發&lt;/li&gt;
&lt;li&gt;其他人都怎麼樣寫程式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些內容在學校課程的訓練中較少，尤其是電機背景的話在寫程式又更為隨性，但這對一個長期的軟體專案是必需的。希望大家能養成這些習慣。&lt;/p&gt;
&lt;p&gt;這些主題需要熟練到什麼程度，見人見智，深入下去每一個都夠花幾個月的時間鑽研，但以一個實驗室專題、或要完成的軟體專案來說都不實際，至少老闆一點都不在意。所以個人覺得，最低標準就是在遇到該課題不懂的地方時，「能知道怎麼下關鍵字查」且「查完的結果能看得懂」。&lt;/p&gt;
&lt;p&gt;系列文原本放在 &lt;a href="https://gist.github.com/ccwang002/368025d3c541ed983892"&gt;Github Gist&lt;/a&gt; 上，但現在有自己的 blog 了，就整理到這邊順便更新。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;學習方式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;問：為什麼不帶大家手把手教學？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;熟練來自生活中的實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows"&gt;給 Windows 使用者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#osx"&gt;給 OSX 使用者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;文章目錄&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;學習方式&lt;/h3&gt;
&lt;p&gt;每一篇都會是一個主題，主題底下會列出一些資源。主題的最後有學習目標，方便讓你評估自己學到什麼程度。學習目標會給一個明確的任務，我盡量讓它能跟（宅宅的）日常生活結合。通常只要完成前一、二個目標就行了，這也不是功課所以不用給我看。但如果你不介意給我看的話，我會分享我主觀的建議。大部份的任務是沒有唯一的正確答案，只要能解決問題都是好方法。&lt;/p&gt;
&lt;p&gt;總之，這些資源不用全看，任務不用全做，大家自己斟酌要花多少時間在不同的主題上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;挑你喜歡的東西盡量鑽，沒有 fu 的就隨便看看會了就好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我會盡量按照難易度排列，中英文的資源都放。&lt;/p&gt;
&lt;h4 id="_2"&gt;問：為什麼不帶大家手把手教學？&lt;/h4&gt;
&lt;p&gt;簡單地說沒空。認真地說，大家的學習速度跟底子都不一樣，同步學只是浪費各位的時間。&lt;/p&gt;
&lt;p&gt;我大概沒有辦法一個一個項目帶大家練習，底下的很多連結只是提供一個學習的窗口，真正要學下去，都是要花一定時間的。所以也不要抱著「只要讀完這些文章就會了○○○」這樣的想法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;白話的來說，這些背景知識就像遊戲的技能樹，基礎技能要先點好才能點進階技能。要把基礎技能點滿了再練等也可能，但不必要一直練等，大家未必喜歡，現實中也不許你練等不解任務。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一開始可能碰到小問題就要查，或者要連續查很多個網頁被導向四、五次才能稍微解答自己的疑問。這個現象是非常正常的，如果大家能撐過初期這段比較挫折的時期，日後要自學軟體基本上就沒問題了。&lt;/p&gt;
&lt;h3 id="_3"&gt;熟練來自生活中的實踐&lt;/h3&gt;
&lt;p&gt;要很快地學好程式，我推薦練習把程式應用在生活中。例如用文字命令列來下載檔案；把自己筆電變成 linux 桌面系統，練習自己編譯軟體、解決各式安裝的狀況。讓自己的電腦成為一個自己能接受的軟體開發環境，並經常的使用它，就能降低對寫程式的陌生與不知所措感。&lt;/p&gt;
&lt;p&gt;上面的方法可能稍難一些，負擔比較小的可以開始做「思考練習」。思考練習包含去想生活中的大小事該怎麼寫程式來控制。例如我該怎麼設計一個電梯系統？臉書怎麼呈現大家的動態？只要大概想一想就好了，想不出來也不會怎樣，也不用特別查資料。過一段時間對程式的 sense 也會提昇。&lt;/p&gt;
&lt;p&gt;如果需要更硬派的學習方式，不妨把自己電腦安裝的軟體的源始碼都拿出來看一下，加入幾個自己平常用的軟體的專案來修改它，讓它更少問題更多功能（一般叫 contribute）。也可以把實驗室有用到的工具的原始碼拿出來看一下，例如 sratoolkit、cutadapt，看看自己能不能讀懂別人的程式碼。&lt;/p&gt;
&lt;h3 id="windows"&gt;給 Windows 使用者&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;建議大家想辦法裝個 Linux（或用 Mac）。如果不想取代掉自己的 Windows 環境話，可以安裝 VirtualBox 裝個虛擬的 Linux，或者在 Amazon 等 VPS 架一台虛擬主機。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows 因為對圖形介面（GUI）設計的很好，也不容易讓使用者用命令列模式（terminal, console)。雖然 Windows 上有像 command prompt、Powershell 之類的環境，但都很難用它來操控整個系統。而且它打從骨子就跟 Linux 不一樣，所以相關的指令不好在網上的教學文章中找到，而多數 Windows 的開發者也不喜歡用 terminal。&lt;/p&gt;
&lt;p&gt;另一方面，大家對 Visual Studio 的印象都是要收錢的&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1"&gt;1&lt;/a&gt;&lt;/sup&gt;，這是 Windows 上最完整最好用的開發環境，不想付費的情況下可能就會覺得「寫程式充滿障礙」，更何況 VS 也是圖形化的編輯器，也會不了解背後運作的方式。市面的開源軟體多半在 *nix 上開發，對 Windows 支援度差也加深這個障礙（「想要自己裝但都一堆限制又很容易失敗」）&lt;/p&gt;
&lt;p&gt;不用 terminal 的壞處是很難想像自己系統中的軟體為什麼能運作。感覺要寫個有 GUI 的程式都要很厲害，跟自己學過的寫程式都不一樣。但實質上是沒有太多區別的，只是要完成一個能安裝在系統中的視窗軟體，需要的步驟多很多，一般簡單的專案都不會到那個階段。&lt;/p&gt;
&lt;h3 id="osx"&gt;給 OSX 使用者&lt;/h3&gt;
&lt;p&gt;Mac OSX 使用者也有這樣的現象，但因為 OSX 在底層用的是跟 FreeBSD 很相似，而 FreeBSD 跟 Linux 相似，所以它的 terminal 環境是很完整的。現在軟體開發者很多人用 OSX，因此網路上 Linux、OSX 資源都很多，兩者的經驗常能自然地移植。&lt;/p&gt;
&lt;p&gt;如何在 OSX 上開發程式，可以參考&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;附錄 0&lt;/a&gt; 的筆記，但內容很主觀，不是每個人都會像我這樣用。&lt;/p&gt;
&lt;h2 id="_4"&gt;文章目錄&lt;/h2&gt;
&lt;p&gt;寫一寫內容也變得蠻多的，所以把它切成了幾篇文章，請按照數字順序閱讀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-intro/"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;Chapter 1 &amp;ndash; Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;Chapter 2 &amp;ndash; Text Editing (Markdown, Text Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;Chapter 3 &amp;ndash; Version Control (Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;Chapter 4 &amp;ndash; Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;Appendix 1 &amp;ndash; OSX Development Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;Appendix 2 &amp;ndash; Python in Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag 也可以找到所有的文章。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;Visual Studio 自 2013 後有 &lt;a href="https://www.visualstudio.com/en-us/news/vs2013-community-vs.aspx"&gt;Community&lt;/a&gt; 版本，免費但內容與 Professional 版本大致無異，所以未來要有 C/C++ 32/64bit Compiler 會更容易。但多數的開源軟體還沒跟進，所以很多還在用舊的 VS 版本（就要付費），這個現象還會持續一陣。學校都有買。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Coding"></category><category term="zh"></category><category term="labcoding"></category></entry></feed>