<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang-Bo Wang's Blog - seqtk</title><link href="https://blog.liang2.tw/" rel="alternate"></link><link href="https://blog.liang2.tw/feeds/tag_seqtk.atom.xml" rel="self"></link><id>https://blog.liang2.tw/</id><updated>2015-09-27T14:11:00-05:00</updated><entry><title>FASTA/Q sequence processing toolkit -- seqtk</title><link href="https://blog.liang2.tw/posts/2015/09/seqtk/" rel="alternate"></link><published>2015-09-27T14:11:00-05:00</published><updated>2015-09-27T14:11:00-05:00</updated><author><name>Liang-Bo Wang</name></author><id>tag:blog.liang2.tw,2015-09-27:/posts/2015/09/seqtk/</id><summary type="html">&lt;p&gt;This post demonstrates the FASTQ to FASTA conversion and sequence quality check using seqtk.&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is the first post of the series of my common NGS processing workflows and notes.&lt;/p&gt;
&lt;p&gt;Some of the most common operation in sequence processing is FASTQ → FASTA conversion. Tons of conversion scripts using either sed or awk can be found by search. For example,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# FASTQ to FASTA&lt;/span&gt;
&lt;span class="c1"&gt;# Assume every read record takes exactly 4 line&lt;/span&gt;
&lt;span class="c1"&gt;# Ref: http://stackoverflow.com/a/10359425&lt;/span&gt;
$ sed -n &lt;span class="s1"&gt;&amp;#39;1~4s/^@/&amp;gt;/p;2~4p&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The assumption of 4 lines per read usually holds for recent NGS sequencing data, so not a big deal.&lt;/p&gt;
&lt;p&gt;In many case the sequence is gzip&amp;rsquo;d. It is still a piece of cake when combining with pipe editing,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;gzcat myseq.fq.gz &lt;span class="p"&gt;|&lt;/span&gt; sed -n &lt;span class="s1"&gt;&amp;#39;1~4s/^@/&amp;gt;/p;2~4p&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; myseq.fa.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, things can get complex really fast when one wants to additionally do reverse complement, randomly sample a subset of reads, and many other types of sequence manipulation. Efficiency matters if those tasks are applied to tens of millions of reads. Even a few nanoseconds longer of computing time difference per read can make a difference at this scale of reads.&lt;/p&gt;
&lt;h3 id="seqtk"&gt;Seqtk&lt;/h3&gt;
&lt;p&gt;So &lt;a href="https://github.com/lh3/seqtk"&gt;seqtk&lt;/a&gt; comes into rescue. It is written in C and MIT licensed. &lt;a href="https://www.biostars.org/p/85929/#86082"&gt;A quick comparison&lt;/a&gt; shows it is generally faster than other UNIX-based solutions, let alone implementations based on scripting languages.&lt;/p&gt;
&lt;p&gt;Seqtk bundles many other operations, but I&amp;rsquo;ll just mention those I frequently use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;$seqtk&lt;/span&gt;

Usage:   seqtk &amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;
Version: &lt;span class="m"&gt;1&lt;/span&gt;.0-r77-dirty

Command: seq       common transformation of FASTA/Q
         comp      get the nucleotide composition of FASTA/Q
         sample    subsample sequences
         subseq    extract subsequences from FASTA/Q
         fqchk     fastq QC &lt;span class="o"&gt;(&lt;/span&gt;base/quality summary&lt;span class="o"&gt;)&lt;/span&gt;
         mergepe   interleave two PE FASTA/Q files
         trimfq    trim FASTQ using the Phred algorithm

         hety      regional heterozygosity
         mutfa     point mutate FASTA at specified positions
         mergefa   merge two FASTA/Q files
         dropse    drop unpaired from interleaved PE FASTA/Q
         rename    rename sequence names
         randbase  choose a random base from hets
         cutN      cut sequence at long N
         listhet   extract the position of each het
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="fastq-fasta"&gt;FASTQ → FASTA&lt;/h3&gt;
&lt;p&gt;Read (gzip&amp;rsquo;d) FASTQ and write out as FASTA,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seqtk seq -A in.fq&lt;span class="o"&gt;[&lt;/span&gt;.gz&lt;span class="o"&gt;]&lt;/span&gt; &amp;gt; out.fa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To make the output gzip&amp;rsquo;d again, piped with gzip,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seqtk seq -A in.fq&lt;span class="o"&gt;[&lt;/span&gt;.gz&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; out.fa.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="reverse-complement"&gt;Reverse complement&lt;/h3&gt;
&lt;p&gt;If one wants to debug the R2 reads of pair-end sequencing (second read on forward strand), since they contain reverse complement sequence of the insert DNA, one needs to reverse complement R2 reads again to debug directly by bare human eyes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seqtk seq -r R2.fq &amp;gt; R2_rc.fq

$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;gt; Example R2 seq&lt;/span&gt;
&lt;span class="s1"&gt;  GCATTGGTGGTTCAGTGGTAGAATTCT&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; seqtk seq -r
&lt;span class="c1"&gt;# &amp;gt; Example R2 seq&lt;/span&gt;
&lt;span class="c1"&gt;# AGAATTCTACCACTGAACCACCAATGC&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="quality-check"&gt;Quality check&lt;/h3&gt;
&lt;p&gt;To be honest, &lt;a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/"&gt;FastQC&lt;/a&gt; is more frequently used for quality check because it generates &lt;a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/good_sequence_short_fastqc.html"&gt;reports with beautiful figures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But for a detail report on each read position, one should consider &lt;code&gt;seqtk fqchk&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ seqtk fqchk myseq.fq&lt;span class="o"&gt;[&lt;/span&gt;.gz&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By default it sets &lt;code&gt;-q 20&lt;/code&gt;. This quality threshold determines the threshold of counting a base as low or high quality, shown as &lt;code&gt;%low&lt;/code&gt; and &lt;code&gt;%high&lt;/code&gt; per read position. In the default case, quality score higher than 20 will be treated as high quality bases.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;min_len: 10; max_len: 174; avg_len: 28.92; 37 distinct quality values
POS #bases    %A   %C   %G   %T   %N  avgQ errQ %low %high
ALL 236344886 17.0 22.5 31.3 29.2 0.0 39.9 37.6 0.1  99.9
1   8172342   8.9  12.4 57.0 21.7 0.0 39.6 29.0 0.5  99.5
2   8172342   7.7  62.5 16.2 13.7 0.0 39.8 37.8 0.2  99.8
3   8172342   50.3 24.1 11.9 13.6 0.0 39.8 38.2 0.1  99.9
4   8172342   10.4 22.9 15.3 51.3 0.0 39.9 38.7 0.1  99.9
5   8172342   14.3 12.9 22.3 50.5 0.0 39.8 37.0 0.2  99.8
# ... (trimmed)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The following columns, &lt;code&gt;avgQ&lt;/code&gt; and &lt;code&gt;errQ&lt;/code&gt;, need more explanation. Average quality (&lt;code&gt;avgQ&lt;/code&gt;) is computed by weighted mean of each base&amp;rsquo;s quality,&lt;/p&gt;
&lt;div class="math"&gt;$$
    \text{avgQ} = \dfrac{\sum_{q=0}^{93} q \cdot n_q}{\sum_{q = 0}^{93} n_q},
$$&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(n_q\)&lt;/span&gt; is the number of bases with quality score being &lt;span class="math"&gt;\(q\)&lt;/span&gt;. The magic number 93 comes from the quality score of Sanger sequencing&lt;sup id="fnref:sanger-qual-score"&gt;&lt;a class="footnote-ref" href="#fn:sanger-qual-score"&gt;1&lt;/a&gt;&lt;/sup&gt;, whose score ranges from 0 to 93.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;errQ&lt;/code&gt; we need more background knowledge about how quality score is computed. A base with quality score &lt;span class="math"&gt;\(q\)&lt;/span&gt; implies the probability of being erroneously called, &lt;span class="math"&gt;\(P_q\)&lt;/span&gt;, is &lt;/p&gt;
&lt;div class="math"&gt;$$
    P_q = 10^{\frac{-q}{10}}, \hspace{1em} q = -10\log_{10}{P_q}.
$$&lt;/div&gt;
&lt;p&gt;Therefore, given &lt;span class="math"&gt;\(q\)&lt;/span&gt; being &lt;span class="math"&gt;\(0, 1, 2, \ldots\)&lt;/span&gt;, seqtk has a conversion table &lt;code&gt;perr&lt;/code&gt; from quality score to probability,&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Q&lt;/th&gt;
&lt;th align="right"&gt;0&lt;/th&gt;
&lt;th align="right"&gt;1&lt;/th&gt;
&lt;th align="right"&gt;2&lt;/th&gt;
&lt;th align="right"&gt;3&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;strong&gt;P&lt;/strong&gt;&lt;/td&gt;
&lt;td align="right"&gt;0.5&lt;/td&gt;
&lt;td align="right"&gt;0.5&lt;/td&gt;
&lt;td align="right"&gt;0.5&lt;/td&gt;
&lt;td align="right"&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Q&lt;/th&gt;
&lt;th align="right"&gt;4&lt;/th&gt;
&lt;th align="right"&gt;5&lt;/th&gt;
&lt;th align="center"&gt;&amp;hellip;&lt;/th&gt;
&lt;th align="right"&gt;38&lt;/th&gt;
&lt;th align="right"&gt;39&lt;/th&gt;
&lt;th align="right"&gt;40&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;strong&gt;P&lt;/strong&gt;&lt;/td&gt;
&lt;td align="right"&gt;0.398107&lt;/td&gt;
&lt;td align="right"&gt;0.316228&lt;/td&gt;
&lt;td align="center"&gt;&amp;hellip;&lt;/td&gt;
&lt;td align="right"&gt;0.000158&lt;/td&gt;
&lt;td align="right"&gt;0.000126&lt;/td&gt;
&lt;td align="right"&gt;0.000100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Based on the probability, it computes the expected number of base call errors, num_err, and the empirical probability of having a base call error at this position, errP, &lt;/p&gt;
&lt;div class="math"&gt;$$
    \text{num_err} = \sum_q P_q \cdot n_q, \hspace{1em} \text{errP} = \frac{\text{num_err}}{\sum_q n_q}.
$$&lt;/div&gt;
&lt;p&gt;Thus the &lt;code&gt;errQ&lt;/code&gt; is the equivalent quality score of errP, which better interprets the probability of base call error than &lt;code&gt;avgQ&lt;/code&gt;, &lt;/p&gt;
&lt;div class="math"&gt;$$
    \text{errQ} = -10\log_{10}{\text{errP}}.
$$&lt;/div&gt;
&lt;p&gt;By passing &lt;code&gt;-q 0&lt;/code&gt; to &lt;code&gt;seqtk fqchk&lt;/code&gt;, one can get the proportion of all distinct quality scores at each position. This information is pretty useful if the sequencing data is all a mess and one needs to figure out the cause.&lt;/p&gt;
&lt;p&gt;Though some of the &lt;code&gt;seqtk fqchk&lt;/code&gt;&amp;lsquo;s behavior is not documented, it should be straight forward enough to understand. All in all, the details can always be found in the &lt;a href="https://github.com/lh3/seqtk/blob/4feb6e81444ab6bc44139dd3a125068f81ae4ad8/seqtk.c#L1483"&gt;source code&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/lh3/seqtk"&gt;Seqtk&lt;/a&gt; is fast to use for daily routines of FASTA/Q conversion. On top of that it provide various functionalities such as read random sampling, quality check, and many I haven&amp;rsquo;t tried or mentioned.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:sanger-qual-score"&gt;
&lt;p&gt;See multiple specifications of quality score at &lt;a href="http://scikit-bio.org/docs/latest/generated/skbio.io.format.fastq.html#quality-score-variants"&gt;sckit-bio doc&lt;/a&gt;. The score is &lt;a href="https://en.wikipedia.org/wiki/Phred_quality_score"&gt;Phred quality score&lt;/a&gt;. More other score representations can be found at &lt;a href="https://en.wikipedia.org/wiki/FASTQ_format"&gt;FASTQ wiki&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:sanger-qual-score" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Note that the probability of q less than 4 is fixed with 0.5. A quick computation can see when &lt;span class="math"&gt;\(q = 3\)&lt;/span&gt;, its actual Phred probability is &lt;span class="math"&gt;\(10 ^ {-0.3} = 0.501\)&lt;/span&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Bioinfo"></category><category term="en"></category><category term="seqtk"></category><category term="NGS"></category></entry></feed>